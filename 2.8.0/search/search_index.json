{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mutiny \u2013 Intuitive Event-Driven Reactive Programming Library for Java","text":"<pre><code>Uni&lt;String&gt; request = makeSomeNetworkRequest(params);\n\nrequest.ifNoItem().after(ofMillis(100))\n    .failWith(() -&gt; new TooSlowException(\"\ud83d\udca5\"))\n    .onFailure(IOException.class).recoverWithItem(fail -&gt; \"\ud83d\udce6\")\n    .subscribe().with(\n        item -&gt; log(\"\ud83d\udc4d \" + item),\n         err -&gt; log(err.getMessage())\n    );\n</code></pre> <p> Get Mutiny 2.8.0</p>"},{"location":"#event-driven","title":"Event-Driven","text":"<p>Mutiny places events at the core of its design.</p> <p>With Mutiny, you observe events, react to them, and create elegant and readable processing pipelines.</p> <p>A PhD in functional programming is not required.</p>"},{"location":"#navigable","title":"Navigable","text":"<p>Even with smart code completion, classes with hundreds of methods are confusing.</p> <p>Mutiny provides a navigable and explicit API driving you towards the operator you need.</p>"},{"location":"#non-blocking-io","title":"Non-blocking I/O","text":"<p>Mutiny is the perfect companion to tame the asynchronous nature of applications with non-blocking I/O.</p> <p>Compose operations in a declarative fashion, transform data, enforce progress, recover from failures and more.</p>"},{"location":"#quarkus-and-vertx-native","title":"Quarkus and Vert.x native","text":"<p>Mutiny is integrated in Quarkus where every reactive API uses Mutiny, and Eclipse Vert.x clients are made available using Mutiny bindings.</p> <p>Mutiny is however an independent library that can ultimately be used in any Java application.</p>"},{"location":"#made-for-an-asynchronous-world","title":"Made for an asynchronous world","text":"<p>Mutiny can be used in any asynchronous application such as event-driven microservices, message-based applications, network utilities, data stream processing, and of course\u2026 reactive applications!</p>"},{"location":"#reactive-converters-built-in","title":"Reactive Converters Built-In","text":"<p>Mutiny is based on the Reactive Streams protocol and Java Flow, and so it can be integrated with any other reactive programming library.</p> <p>In addition, it proposes converters to interact with other popular libraries.</p>"},{"location":"guides/branching/","title":"How to do branching in a reactive pipeline?","text":"<p>Mutiny and similar reactive programming libraries do not have branching operators similar to <code>if / else</code> and <code>switch/case</code> statements in Java.</p> <p>This does not mean that we can\u2019t express branching in a reactive pipeline, and the most classic way is to use a transformation to a <code>Uni</code> (also called <code>flatMap</code> in functional programming).</p>","tags":["guide","intermediate"]},{"location":"guides/branching/#expressing-branches-as-uni-operations","title":"Expressing branches as Uni operations","text":"<p>Suppose that we have a pipeline where a <code>Uni</code> is created from a random value, and suppose that we want to have a different processing pipeline depending on whether the value is odd or even. Let\u2019s have these 2 <code>Uni</code>-returning methods to model different behaviors:</p> <pre><code>Uni&lt;String&gt; evenOperation(int n) {\n    return Uni.createFrom().item(\"Even number: \" + n)\n            .onItem().invoke(() -&gt; System.out.println(\"(even branch)\"));\n}\n\nUni&lt;String&gt; oddOperation(int n) {\n    return Uni.createFrom().item(\"Odd number: \" + n)\n            .onItem().invoke(() -&gt; System.out.println(\"(odd branch)\"));\n}\n</code></pre> <p>We can use the <code>transformToUni</code> operator to plug either method depending on the random number:</p> <pre><code>Random random = new Random();\nUni.createFrom().item(() -&gt; random.nextInt(100))\n        .onItem().transformToUni(n -&gt; {\n            if (n % 2 == 0) {\n                return evenOperation(n);\n            } else {\n                return oddOperation(n);\n            }\n        })\n        .subscribe().with(System.out::println);\n</code></pre> <p>Having such a mapping function is a common pattern: it has conditional logic and each branch returns a <code>Uni</code> that represents the \u201csub-pipeline\u201d of what each branch shall do.</p> <p>Note that such constructs are primarily relevant when asynchronous I/O are involved and that such asynchronous I/O operations are typically <code>Uni</code>-returning methods such as those found in the Mutiny Vert.x bindings.</p> <p>Tip</p> <p>There are other ways to express the \u201cresult\u201d of a branch. You could wrap results in a custom type or a container like <code>java.util.Optional</code>.</p> <p>You could also return a failed <code>Uni</code>, and later react by continuing with another <code>Uni</code>, another value, or retrying (which would model a loop!).</p>","tags":["guide","intermediate"]},{"location":"guides/branching/#branching-in-a-multi","title":"Branching in a Multi","text":"<p>The case of <code>Multi</code> is even more interesting because a <code>null</code>-completed <code>Uni</code> is discarded from the stream by any of the <code>transformToUni{...}</code> methods:</p> <pre><code>Random random = new Random();\nMulti.createBy().repeating().supplier(random::nextInt).atMost(20)\n        .onItem().transformToUniAndMerge(n -&gt; {\n            System.out.println(\"----\");\n            if (n &lt; 0) {\n                return drop();\n            } else if (n % 2 == 0) {\n                return evenOperation(n);\n            } else {\n                return oddOperation(n);\n            }\n        })\n        .subscribe().with(str -&gt; System.out.println(\"=&gt; \" + str));\n</code></pre> <p>where <code>drop()</code> is as follows:</p> <pre><code>Uni&lt;String&gt; drop() {\n    return Uni.createFrom().&lt;String&gt;nullItem()\n            .onItem().invoke(() -&gt; System.out.println(\"(dropping negative value)\"));\n}\n</code></pre> <p>Any negative value is discarded in this <code>Multi</code> pipeline, while the positive even and odd numbers get forwarded to the subscriber.</p>","tags":["guide","intermediate"]},{"location":"guides/broadcasting-to-multiple-subscribers/","title":"Broadcasting to multiple subscribers (like server-sent events, websockets, etc)","text":"<p>It is a common requirement in event-driven applications to have multiple subscribers receiving events from a single events source:</p> <pre><code>flowchart LR\n    source[Events source]\n    proc[Publisher]\n    sub1[Subscriber 1]\n    sub2[Subscriber 2]\n    sub3[Subscriber 3]\n    source -- a, b, c --&gt; proc\n    proc -- a, b, c --&gt; sub1 &amp; sub2 &amp; sub3</code></pre> <p>A good example would be a periodic events stream where the events get pushed every second to multiple server-sent event subscribers.</p> <p>Let us see how this can be done using Mutiny and the Quarkus framework.</p> <p>Note</p> <p>We use Quarkus to illustrate a classic real-world usage for the broadcast operator, but the same kind of construct could be done with another framework or the Vert.x toolkit.</p>","tags":["guide","beginner"]},{"location":"guides/broadcasting-to-multiple-subscribers/#use-case-dynamic-subscribers","title":"Use-case: dynamic subscribers","text":"<p>We expose a HTTP endpoint for server-sent events, and each second we receive the current list of subscribers. The endpoint is exposed on path <code>/hello/ticks/{id}</code> where <code>id</code> is an identifier for a subscriber.</p> <p>We could subscribe and follow the stream using HTTPie for subscriber <code>1</code>:</p> <pre><code>$ http --stream :8080/hello/ticks/1\nHTTP/1.1 200 OK\nContent-Type: text/event-stream\nX-SSE-Content-Type: text/plain\ntransfer-encoding: chunked\n\ndata:1\n\ndata:1\n\ndata:1\n\ndata:1,2\n\ndata:1,2\n</code></pre> <p>The first 3 ticks have just one subscriber (<code>data:1</code>), but then once another subscriber arrives at path <code>/hello/ticks/2</code> we get ticks with identifiers <code>1,2</code>. </p> <p>When the connection for subscriber <code>1</code> closes, we see the impact on subscriber <code>2</code>:</p> <pre><code>http --stream :8080/hello/ticks/2\nHTTP/1.1 200 OK\nContent-Type: text/event-stream\nX-SSE-Content-Type: text/plain\ntransfer-encoding: chunked\n\ndata:1,2\n\ndata:1,2\n\ndata:2\n\ndata:2\n\ndata:2\n</code></pre>","tags":["guide","beginner"]},{"location":"guides/broadcasting-to-multiple-subscribers/#why-is-broadcasting-required","title":"Why is broadcasting required?","text":"<p>Mutiny offers a publisher for periodic event streams:</p> <pre><code>var ticks = Multi.createFrom().ticks().every(Duration.ofSeconds(1));\n</code></pre> <p>You might wonder why we couldn\u2019t simply build our Quarkus endpoints as in:</p> <pre><code>@Path(\"/hello\")\npublic class GreetingResource {\n\n    @GET\n    @Path(\"ticks/{id}\")\n    @RestStreamElementType(MediaType.TEXT_PLAIN)\n    public Multi&lt;String&gt; ticks(String id) {\n        return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n                // (rest of the pipeline...)\n            ;\n    }\n}\n</code></pre> <p>The problem here is that instead of having a single events source to emit ticks, you will have as many as there are subscribers:</p> <pre><code>flowchart LR\n    source1[Events source]\n    source2[Events source]\n    source3[Events source]\n    proc1[Publisher]\n    proc2[Publisher]\n    proc3[Publisher]\n    sub1[Subscriber 1]\n    sub2[Subscriber 2]\n    sub3[Subscriber 3]\n    source1 -- a, b, c --&gt; proc1\n    source2 -- a, b, c --&gt; proc2\n    source3 -- a, b, c --&gt; proc3\n    proc1 -- a, b, c --&gt; sub1\n    proc2 -- a, b, c --&gt; sub2\n    proc3 -- a, b, c --&gt; sub3</code></pre> <p>You might be able to articulate some logic around such construct, but you will end up with many scheduled operations on the Quarkus thread pool.</p> <p>Even worse: if your source is not periodic ticks emitted by Mutiny but some event source (e.g., a Kafka topic, a message broker queue, etc) then you might add correctness issues (e.g., not all subscribers get all messages).</p>","tags":["guide","beginner"]},{"location":"guides/broadcasting-to-multiple-subscribers/#broadcasting-listening-to-subscriptions-and-cancellations","title":"Broadcasting, listening to subscriptions and cancellations","text":"<p>It is fortunately quite easy to express such construct by sharing a common <code>Multi</code>, and broadcasting events to each subscriber.</p> <p>Let\u2019s start with the HTTP endpoint:</p> <pre><code>private ConcurrentHashSet&lt;String&gt; identifiers = new ConcurrentHashSet&lt;&gt;();\n\nprivate Multi&lt;String&gt; ticks = (...);\n\n@GET\n@Path(\"ticks/{id}\")\n@RestStreamElementType(MediaType.TEXT_PLAIN)\npublic Multi&lt;String&gt; ticks(String id) {\n    Log.info(\"New client with id \" + id);\n    identifiers.add(id);\n    return ticks.onCancellation().invoke(() -&gt; {\n        Log.info(\"Removing client with id \" + id);\n        identifiers.remove(id);\n    });\n}\n</code></pre> <p>The <code>ticks</code> method registers a new client in <code>identifiers</code>, and removes it upon cancellation. The returned <code>Multi</code> pipeline piggy-backs on top of the shared <code>Multi</code>, which is built as follows:</p> <pre><code>private Multi&lt;String&gt; ticks = Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n        .onItem().transform(tick -&gt; {\n            Log.info(\"tick\");\n            return identifiers.stream().collect(Collectors.joining(\",\"));\n        })\n        .onSubscription().invoke(() -&gt; Log.info(\"Starting to emit ticks\"))\n        .onCancellation().invoke(() -&gt; Log.info(\"No more ticks\"))\n        .broadcast()\n            .withCancellationAfterLastSubscriberDeparture()\n            .toAtLeast(1);\n</code></pre> <p>Here are a few observations.</p> <ol> <li>For each periodic tick event, we assemble the current subscribers as a string of the form <code>\"1,2,3\"</code> with <code>.onItem().transform(...)</code>.</li> <li>We log an event when the periodic event stream starts (see <code>onSubscription().invoke(...)</code>).</li> <li>We log an event when the periodic event stream stops (see <code>onCancellation().invoke(...)</code>).</li> <li>We broadcast events to all subscribers, but:</li> <li>there must be at least one subscriber before the stream starts, and</li> <li>the stream is cancelled when the last subscriber departs.</li> </ol> <p>This construction is quite interesting because we don\u2019t emit ticks when there are no subscribers, and we stop it when there are none.</p> <p>If you play with such an example then you will see logs similar to these:</p> <pre><code>INFO  [org.acm.GreetingResource] (vert.x-eventloop-thread-0) New client with id 1\nINFO  [org.acm.GreetingResource] (vert.x-eventloop-thread-0) Starting to emit ticks\nINFO  [org.acm.GreetingResource] (executor-thread-1) tick\nINFO  [org.acm.GreetingResource] (executor-thread-1) tick\nINFO  [org.acm.GreetingResource] (vert.x-eventloop-thread-0) Removing client with id 1\nINFO  [org.acm.GreetingResource] (vert.x-eventloop-thread-0) No more ticks\nINFO  [org.acm.GreetingResource] (vert.x-eventloop-thread-1) New client with id 1\nINFO  [org.acm.GreetingResource] (vert.x-eventloop-thread-1) Starting to emit ticks\nINFO  [org.acm.GreetingResource] (executor-thread-1) tick\nINFO  [org.acm.GreetingResource] (executor-thread-1) tick\nINFO  [org.acm.GreetingResource] (executor-thread-1) tick\nINFO  [org.acm.GreetingResource] (vert.x-eventloop-thread-0) New client with id 2\nINFO  [org.acm.GreetingResource] (executor-thread-1) tick\nINFO  [org.acm.GreetingResource] (executor-thread-1) tick\nINFO  [org.acm.GreetingResource] (vert.x-eventloop-thread-1) Removing client with id 1\nINFO  [org.acm.GreetingResource] (executor-thread-1) tick\nINFO  [org.acm.GreetingResource] (executor-thread-1) tick\nINFO  [org.acm.GreetingResource] (executor-thread-1) tick\nINFO  [org.acm.GreetingResource] (vert.x-eventloop-thread-0) Removing client with id 2\nINFO  [org.acm.GreetingResource] (vert.x-eventloop-thread-0) No more ticks\n</code></pre>","tags":["guide","beginner"]},{"location":"guides/collecting-items/","title":"Collecting items from Multi","text":"<p>There are cases where you want to accumulate the items from a <code>Multi</code> and produce a <code>Uni</code> as a final result. This is also called a reduction in functional programming.</p> <p>The <code>Uni</code> fires its item when the <code>Multi</code> completes. Mutiny provides multiple operators to deal with that scenario. They are available from the <code>collect()</code> group. For example, you can store the items in a list, emit the list on completion, or use a Java <code>Collector</code> to customize the aggregation.</p> <p>Danger</p> <p>Don\u2019t collect items from infinite streams or you will likely end with an out-of-memory failure!</p>","tags":["guide","beginner"]},{"location":"guides/collecting-items/#collecting-items-into-a-list","title":"Collecting items into a list","text":"<p>One of the most common approaches to collect items is to store them in a list (<code>Uni&lt;List&lt;T&gt;&gt;</code>) It emits the final list when the <code>Multi</code> completes.</p> <pre><code>sequenceDiagram\n    autonumber\n    participant M as Multi\n    participant O as Collect operator\n    participant D as Subscriber\n\n    M-&gt;&gt;O: onItem(1)\n    M-&gt;&gt;O: onItem(2)\n    M-&gt;&gt;O: onItem(3)\n\n    O-&gt;&gt;D: onItem([1, 2, 3])</code></pre> <p>How to achieve this with Mutiny?</p> <pre><code>Multi&lt;String&gt; multi = getMulti();\nUni&lt;List&lt;String&gt;&gt; uni = multi.collect().asList();\n</code></pre> <p>It\u2019s important to note that the returned type is a <code>Uni</code>. It emits the list when the multi completes.</p>","tags":["guide","beginner"]},{"location":"guides/collecting-items/#collecting-items-into-a-map","title":"Collecting items into a map","text":"<p>You can also collect the items into a <code>Map</code>. In this case, you need to provide a function to compute the key for each item:</p> <pre><code>Multi&lt;String&gt; multi = getMulti();\nUni&lt;Map&lt;String, String&gt;&gt; uni =\n        multi.collect()\n                .asMap(item -&gt; getUniqueKeyForItem(item));\n</code></pre> <p>If the key mapper function returns the same key for multiple items, the last one with that key is stored in the final <code>Map</code>. You can collect items in a multimap to handle items with the same keys.</p>","tags":["guide","beginner"]},{"location":"guides/collecting-items/#collecting-items-into-a-multimap","title":"Collecting items into a multimap","text":"<p>A multimap is a <code>Map&lt;K, List&lt;T&gt;&gt;.</code> In the case of a conflicting key, it stores all the items in a list associated with that key.</p> <pre><code>Multi&lt;String&gt; multi = getMulti();\nUni&lt;Map&lt;String, Collection&lt;String&gt;&gt;&gt; uni =\n        multi.collect()\n                .asMultiMap(item -&gt; getKeyForItem(item));\n</code></pre>","tags":["guide","beginner"]},{"location":"guides/collecting-items/#using-a-custom-accumulator","title":"Using a custom accumulator","text":"<p>You can also use a custom accumulator function:</p> <pre><code>Multi&lt;String&gt; multi = getMulti();\nUni&lt;MyCollection&gt; uni = multi.collect()\n        .in(MyCollection::new, (col, item) -&gt; col.add(item));\n</code></pre> <p>The <code>in</code> method receives two arguments:</p> <ol> <li>a supplier providing the new instance of your collection/container</li> <li>the accumulator function</li> </ol> <p>You can also use a Java <code>Collector</code>. For example, in the next example, count the number of items, and produce the final count as item:</p> <pre><code>Uni&lt;Long&gt; count = multi.collect()\n        .with(Collectors.counting());\n</code></pre>","tags":["guide","beginner"]},{"location":"guides/collecting-items/#getting-the-first-and-last-items","title":"Getting the first and last items","text":"<p>While they are not strictly speaking collecting items, <code>collect().first()</code> and <code>collect().last()</code> allow retrieving the first and last item from a <code>Multi</code>:</p> <pre><code>Uni&lt;String&gt; first = multi.collect().first();\nUni&lt;String&gt; last = multi.collect().last();\n</code></pre>","tags":["guide","beginner"]},{"location":"guides/combining-items/","title":"Combining items from streams","text":"<p>Combining items from various streams is an essential pattern in Reactive Programming.</p> <p>It associates the emitted items from multiple streams and emits an aggregate. The downstream receives this aggregate and can handle it smoothly.</p> <p>There are plenty of use cases, such as executing two tasks concurrently and waiting for both completions, getting the last items from different streams to build an always up-to-date view, and so on.</p>","tags":["guide","intermediate"]},{"location":"guides/combining-items/#combining-unis","title":"Combining Unis","text":"<p>Imagine that you have two asynchronous operations to perform like 2 HTTP requests. You want to send these requests and be notified when both have completed with their responses ready to be consumed.</p> <p>Of course, you could send the first request, wait for the response, and then send the second request. If both requests are independent, we can do something better: send both concurrently and await for both completions!</p> <pre><code>sequenceDiagram\n    autonumber\n    participant A as Stream A\n    participant B as Stream B\n    participant M as Combined stream\n    participant S as Subscriber \n\n    A-&gt;&gt;M: onItem(1)\n    B-&gt;&gt;M: onItem(a)\n\n    M-&gt;&gt;S: onItem([1,a])\n\n    A-&gt;&gt;M: onItem(2)\n    B-&gt;&gt;M: onItem(b)\n\n    M-&gt;&gt;S: onItem([2,b])</code></pre> <p>How can you achieve this with Mutiny?</p> <p>First, each request is a <code>Uni</code>, so we have:</p> <pre><code>Uni&lt;Response&gt; uniA = invokeHttpServiceA();\nUni&lt;Response&gt; uniB = invokeHttpServiceB();\n</code></pre> <p>Then, we want to combine both responses:</p> <pre><code>Uni&lt;Tuple2&lt;Response, Response&gt;&gt; responses = Uni.combine()\n        .all().unis(uniA, uniB).asTuple();\n</code></pre> <p>This code creates a new <code>Uni</code> produced by combining <code>uniA</code> and <code>uniB</code>. The responses are aggregated inside a <code>Tuple</code>:</p> <pre><code>Uni.combine().all().unis(uniA, uniB).asTuple()\n        .subscribe().with(tuple -&gt; {\n    System.out.println(\"Response from A: \" + tuple.getItem1());\n    System.out.println(\"Response from B: \" + tuple.getItem2());\n});\n</code></pre> <p>The <code>tuple</code> aggregates the responses in the same order as the <code>Uni</code> sequence.</p> <p>If one of the <code>Uni</code> fails, so does the combination and you receive the failure:</p> <pre><code>Uni&lt;Response&gt; uniA = invokeHttpServiceA();\nUni&lt;Response&gt; uniB = invokeHttpServiceB();\n\nUni&lt;Tuple2&lt;Response, Response&gt;&gt; responses = Uni.combine()\n        .all().unis(uniA, uniB).asTuple();\n\nUni.combine().all().unis(uniA, uniB).asTuple()\n        .subscribe().with(tuple -&gt; {\n    System.out.println(\"Response from A: \" + tuple.getItem1());\n    System.out.println(\"Response from B: \" + tuple.getItem2());\n});\n</code></pre> <p>Using tuples is convenient but only works if you have less than 10 <code>Uni</code> objects. If you want another structure or deal with 10 <code>Uni</code> objects or more then use <code>combineWith</code>:</p> <pre><code>Uni&lt;Map&lt;String, Response&gt;&gt; uni = Uni.combine()\n        .all().unis(uniA, uniB).with(\n                listOfResponses -&gt; {\n                    Map&lt;String, Response&gt; map = new LinkedHashMap&lt;&gt;();\n                    map.put(\"A\", (Response) listOfResponses.get(0));\n                    map.put(\"B\", (Response) listOfResponses.get(1));\n                    return map;\n                }\n        );\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/combining-items/#combining-multis","title":"Combining Multis","text":"<p>Combining <code>Multis</code> consists of associating items from different stream per index:</p> <pre><code>sequenceDiagram\n    autonumber\n    participant A as Stream A\n    participant B as Stream B\n    participant M as Combined stream\n    participant S as Subscriber \n\n    A-&gt;&gt;M: onItem(1)\n    A-&gt;&gt;M: onItem(2)\n    B-&gt;&gt;M: onItem(a)\n\n    M-&gt;&gt;S: onItem([1,a])\n\n    A-&gt;&gt;M: onItem(3)\n    B-&gt;&gt;M: onItem(b)\n    M-&gt;&gt;S: onItem([2,b])\n\n    B-&gt;&gt;M: onItem(c)</code></pre> <p>It associates the first items from the combined streams, then the second items:</p> <pre><code>Multi&lt;Tuple2&lt;A, B&gt;&gt; combined = Multi.createBy().combining()\n        .streams(multiA, multiB).asTuple();\n</code></pre> <p>As for <code>Uni</code>, you can aggregate the item into tuples (up to 9 items) or combine with a combinator function:</p> <pre><code>Multi.createBy().combining()\n        .streams(multiA, multiB).using(list -&gt; combineItems(list))\n        .subscribe().with(x -&gt; {\n            // do something with the combined items\n        });\n</code></pre> <p>If one of the streams fails, the combined stream propagates the failure and stops the emission. The combined stream completes as soon as one of the observed stream sends the completion event.</p> <p>Note</p> <p>If one of the observed streams never emits any item then the combined stream will not emit anything.</p>","tags":["guide","intermediate"]},{"location":"guides/combining-items/#combining-the-latest-items-of-multis","title":"Combining the latest items of Multis","text":"<p>It can be useful to combine multiple <code>Multi</code> streams and receive the latest items from each stream on every emission:</p> <pre><code>sequenceDiagram\n    autonumber\n    participant A as Stream A\n    participant B as Stream B\n    participant M as Combined stream\n    participant S as Subscriber \n\n    A-&gt;&gt;M: onItem(1)\n    A-&gt;&gt;M: onItem(2)\n    B-&gt;&gt;M: onItem(a)\n\n    M-&gt;&gt;S: onItem([2,a])\n\n    A-&gt;&gt;M: onItem(3)\n    M-&gt;&gt;S: onItem([3,a])\n    B-&gt;&gt;M: onItem(b)\n    M-&gt;&gt;S: onItem([3,b])\n\n    B-&gt;&gt;M: onItem(c)\n    M-&gt;&gt;S: onItem([3,c])</code></pre> <p>This is achieved using <code>latest()</code>:</p> <pre><code>Multi&lt;Tuple2&lt;A, B&gt;&gt; multi1 = Multi.createBy().combining()\n        .streams(multiA, multiB)\n        .latestItems().asTuple();\n\n// or\n\nMulti&lt;String&gt; multi2 = Multi.createBy().combining()\n        .streams(multiA, multiB)\n        .latestItems().using(list -&gt; combineItems(list));\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/completion-stage/","title":"How to deal with CompletionStage?","text":"<p><code>CompletionStage</code> and <code>CompletableFuture</code> are classes provided by Java to represent asynchronous actions.</p>","tags":["guide","intermediate"]},{"location":"guides/completion-stage/#differences-between-uni-and-completionstage","title":"Differences between Uni and CompletionStage","text":"<p>While <code>CompletionStage</code> and <code>CompletableFuture</code> are close to <code>Uni</code> in terms of use case, there are some fundamental differences.</p> <p><code>CompletionStage</code> are eager. When a method returns a <code>CompletionStage,</code> the operation has already been triggered. The outcome is used to complete the returned <code>CompletionStage</code>. On the other side, <code>Unis</code> are lazy. The operation is only triggered once there is a subscription.</p> <p><code>CompletionStage</code> caches the outcome. So, once received, you can retrieve the result. Every retrieval will get the same result. With <code>Uni</code>, every subscription has the opportunity to re-trigger the operation and gets a different result.</p> <p>Tip</p> <p>You can also cache the outcome with <code>Uni.memoize().indefinitely()</code>.</p>","tags":["guide","intermediate"]},{"location":"guides/completion-stage/#from-uni-to-completionstage","title":"From Uni to CompletionStage","text":"<p>You can create a <code>CompletionStage</code> from <code>Uni</code> using <code>uni.subscribeAsCompletionStage()</code>.</p> <pre><code>CompletionStage&lt;String&gt; cs = uni.subscribeAsCompletionStage();\n</code></pre> <p>It\u2019s important to understand that retrieving a <code>CompletionStage</code> subscribes to the <code>Uni</code>. If you do this operation twice, it subscribes to the <code>Uni</code> twice and re-trigger the operation.</p> <pre><code>// Trigger the underlying operation twice:\nCompletionStage&lt;String&gt; cs1 = uni.subscribeAsCompletionStage();\nCompletionStage&lt;String&gt; cs2 = uni.subscribeAsCompletionStage();\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/completion-stage/#creating-a-uni-from-a-completionstage","title":"Creating a Uni from a CompletionStage","text":"<p>To create a <code>Uni</code> from a <code>CompletionStage</code>, use <code>Uni.createFrom().completionStage(...)</code>.</p> <pre><code>Uni&lt;String&gt; uni1 = Uni\n        // Create from a Completion Stage\n        .createFrom().completionStage(\n                CompletableFuture.supplyAsync(() -&gt; \"hello\", executor)\n        )\n        .onItem().transform(String::toUpperCase);\n\nUni&lt;String&gt; uni2 = Uni\n        // Create from a Completion Stage supplier (recommended)\n        .createFrom().completionStage(\n                () -&gt; CompletableFuture.supplyAsync(() -&gt; \"hello\", executor)\n        )\n        .onItem().transform(String::toUpperCase);\n</code></pre> <p>As you can see, there are two versions. The first one receives the <code>CompletionStage</code> directly, while the second one gets a supplier. In the case of multiple subscriptions on the produced <code>Uni</code>, the supplier is called multiple times (once per subscription), and so can change the return <code>CompletionStage</code>. It also delays the creation of the <code>CompletionStage</code> until there is a subscription, which only triggers the operation at that time. If you pass the instance directly, it will always use the same one (even for multiple subscriptions) and triggers the operation even if there is no subscription. For these reasons, it is generally better to use the variant accepting a supplier.</p> <p>Note that if the completion stage produces a <code>null</code> value, the resulting <code>Uni</code> emits <code>null</code> as item. If the completion stages complete exceptionally, the failure is emitted by the resulting <code>Uni</code>.</p>","tags":["guide","intermediate"]},{"location":"guides/completion-stage/#creating-a-multi-from-a-completionstage","title":"Creating a Multi from a CompletionStage","text":"<p>To create a <code>Multi</code> from a <code>CompletionStage</code>, use <code>Multi.createFrom().completionStage(...)</code>. It produces:</p> <ul> <li>a multi emitting an item and completing - if the value produced by the completion stage is not <code>null</code>,</li> <li>an empty multi if the value produced by the completion stage is <code>null</code>,</li> <li>a failed multi is completion stage is completed exceptionally.</li> </ul> <pre><code>Multi&lt;String&gt; multi1 = Multi\n        .createFrom().completionStage(\n                CompletableFuture.supplyAsync(() -&gt; \"hello\", executor)\n        )\n        .onItem().transform(String::toUpperCase);\n\nMulti&lt;String&gt; multi2 = Multi\n        .createFrom().completionStage(() -&gt;\n                CompletableFuture.supplyAsync(() -&gt; \"hello\", executor)\n        )\n        .onItem().transform(String::toUpperCase);\n</code></pre> <p>For the same reason as for <code>Uni</code>, there are two versions:</p> <ol> <li>one accepting a <code>CompletionStage</code> directly</li> <li>one accepting a <code>Supplier&lt;CompletionStage&gt;</code>, called at subscription-time, for every subscription.</li> </ol> <p>It is recommended to use the second version.</p>","tags":["guide","intermediate"]},{"location":"guides/context-passing/","title":"Context passing","text":"<p>Mutiny reactive pipelines let data flow from publishers to subscribers.</p> <p>In the vast majority of cases a publisher shall have all required data, and operators shall perform processing based on item values. For instance a network request shall be made with all request data known in advance, and response processing shall only depend on the response payload.</p> <p>That being said there are cases were this is not sufficient, and some data has to be carried along with items. For instance one intermediary operator in a pipeline may have to make another networked request from which we need to extract some correlation identifier which will be used by another operator down the pipeline. In such cases one will be tempted to forward tuples consisting of some item value plus some \u201cextra\u201d data.</p> <p>For such cases Mutiny offers a subscriber-provided context, so all operators involved in a subscription can share some form of implicit data.</p>","tags":["guide","advanced"]},{"location":"guides/context-passing/#whats-in-a-context","title":"What\u2019s in a context?","text":"<p>A context is a simple key / value, in-memory storage. Data can be queried, added and deleted from a context, as shown in the following snippet:</p> <pre><code>// Create a context using key / value pairs\nContext context = Context.of(\n        \"X-CUSTOMER-ID\", \"1234\",\n        \"X-SPAN-ID\", \"foo-bar-baz\"\n);\n\n// Get an entry\nSystem.out.println(\n        context.&lt;String&gt;get(\"X-SPAN-ID\"));\n\n// Get an entry, use a supplier for a default value if the key is not present\nSystem.out.println(\n        context.getOrElse(\"X-SPAN-ID\", () -&gt; \"&lt;no id&gt;\"));\n\n// Add an entry\ncontext.put(\"foo\", \"bar\");\n\n// Remove an entry\ncontext.delete(\"foo\");\n</code></pre> <p><code>Context</code> objects are thread-safe, and can be created from sequences of key / value pairs (as shown above), from a Java <code>Map</code>, or they can be created empty.</p> <p>Note that an empty-created context defers its internal storage allocation until the first call to <code>put</code>. You can see <code>Context</code> as a glorified <code>ConcurrentHashMap</code> delegate, although this is an implementation detail and Mutiny might explore various internal storage strategies in the future.</p> <p>Tip</p> <p>Contexts shall be primarily used to share transient data used for networked I/O processing such as correlation identifiers, tokens, etc.</p> <p>They should not be used as general-purpose data structures that are frequently updated and that hold large amounts of data.</p>","tags":["guide","advanced"]},{"location":"guides/context-passing/#how-to-access-a-context","title":"How to access a context?","text":"<p>Given a <code>Uni</code> or a <code>Multi</code>, a context can be accessed using the <code>withContext</code> operator, as in:</p> <pre><code>Context context = Context.of(\"X-CUSTOMER-ID\", customerId);\n\npipeline.withContext((multi, ctx) -&gt; multi.onItem().transformToUniAndMerge(item -&gt; makeRequest(item, ctx.get(\"X-CUSTOMER-ID\"))))\n        .subscribe().with(context, item -&gt; handleResponse(item), err -&gt; handleFailure(err));\n</code></pre> <p>This operator builds a sub-pipeline using 2 parameters: the current <code>Uni</code> or <code>Multi</code> and the context.</p> <p>Important</p> <p>The function passed to <code>withContext</code> is called at subscription time.</p> <p>This means that the context has not had a chance to be updated by upstream operators yet, so be careful with what you do in the body of that function.</p> <p>There is another way to access the context by using the <code>attachContext</code> method:</p> <pre><code>Context context = Context.of(\"X-CUSTOMER-ID\", customerId);\n\npipeline.attachContext()\n        .onItem().transformToUniAndMerge(item -&gt; makeRequest(item.get(), item.context().get(\"X-CUSTOMER-ID\")))\n        .subscribe().with(context, item -&gt; handleResponse(item), err -&gt; handleFailure(err));\n</code></pre> <p>This method materializes the context in the regular pipeline items using the wrapper <code>ItemWithContext</code> class. The <code>get</code> method provides the item while the <code>context</code> method provides the context.</p>","tags":["guide","advanced"]},{"location":"guides/context-passing/#how-to-access-a-context-at-the-pipeline-source","title":"How to access a context at the pipeline source?","text":"<p>The <code>Uni</code> and <code>Multi</code> builder methods like <code>Multi.createFrom()</code> provide publishers, not operators, so they don\u2019t have the <code>withContext</code> method.</p> <p>The first option is to use the <code>Uni.createFrom().context(...)</code> or <code>Multi.createFrom().context(...)</code> general purpose method to materialize the context:</p> <pre><code>Uni.createFrom().context(ctx -&gt; makeRequest(\"db1\", ctx.get(\"X-SPAN-ID\")))\n        .subscribe().with(context, item -&gt; handleResponse(item), err -&gt; handleFailure(err));\n</code></pre> <p>The <code>context</code> method takes a function that accepts a <code>Context</code> and returns a pipeline. This is very similar to the <code>deferred</code> builder.</p> <p>If you use an <code>emitter</code> builder then for both <code>Uni</code> and <code>Multi</code> cases the emitter object offers a <code>context</code> method to access the context:</p> <pre><code>Multi.createFrom().emitter(emitter -&gt; {\n    String customerId = emitter.context().get(\"X-SPAN-ID\");\n    for (int i = 0; i &lt; 10; i++) {\n        emitter.emit(\"@\" + i + \" [\" + customerId + \"]\");\n    }\n    emitter.complete();\n});\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/controlling-demand/","title":"Controlling the demand","text":"","tags":["guide","advanced"]},{"location":"guides/controlling-demand/#pacing-the-demand","title":"Pacing the demand","text":"<p>A subscription is used for 2 purposes: cancelling a request and demanding batches of items.</p> <p>The <code>Multi.paceDemand()</code> operator can be used to automatically issue requests at certain points in time.</p> <p>The following example issues requests of 25 items every 100ms:</p> <pre><code>FixedDemandPacer pacer = new FixedDemandPacer(25L, Duration.ofMillis(100L));\n\nMulti&lt;Integer&gt; multi = Multi.createFrom().range(0, 100)\n        .paceDemand().on(Infrastructure.getDefaultWorkerPool()).using(pacer);\n</code></pre> <p><code>FixedDemandPacer</code> is a simple pacer with a fixed demand and a fixed delay.</p> <p>You can create more elaborated pacers by implementing the <code>DemandPacer</code> interface. To do so you provide an initial request and a function to evaluate the next request which is evaluated based on the previous request and the number of items emitted since the last request:</p> <pre><code>DemandPacer pacer = new DemandPacer() {\n\n    @Override\n    public Request initial() {\n        return new Request(10L, Duration.ofMillis(100L));\n    }\n\n    @Override\n    public Request apply(Request previousRequest, long observedItemsCount) {\n        return new Request(previousRequest.demand() * 2, previousRequest.delay().plus(10, ChronoUnit.MILLIS));\n    }\n};\n</code></pre> <p>The previous example is a custom pacer that doubles the demand and increases the delay for each new request.</p>","tags":["guide","advanced"]},{"location":"guides/controlling-demand/#capping-the-demand-requests","title":"Capping the demand requests","text":"<p>The <code>capDemandsTo</code> and <code>capDemandUsing</code> operators can be used to cap the demand from downstream subscribers.</p> <p>The <code>capDemandTo</code> operator defines a maximum demand that can flow:</p> <pre><code>AssertSubscriber&lt;Integer&gt; sub = AssertSubscriber.create();\n\nsub = Multi.createFrom().range(0, 100)\n        .capDemandsTo(50L)\n        .subscribe().withSubscriber(sub);\n\n// A first batch of 50 (capped), 25 remain outstanding\nsub.request(75L).assertNotTerminated();\nassertThat(sub.getItems()).hasSize(50);\n\n// Second batch: 25 + 25 = 50\nsub.request(25L).assertCompleted();\nassertThat(sub.getItems()).hasSize(100);\n</code></pre> <p>Here we cap requests to 50 items, so it takes 2 requests to get all 100 items of the upstream range. The first request of 75 items is capped to a request of 50 items, leaving an outstanding demand of 25 items. The second request of 25 items is added to the outstanding demand, resulting in a request of 50 items and completing the stream.</p> <p>You can also define a custom function that provides a capping value based on a custom formula, or based on earlier demand observations:</p> <pre><code>AssertSubscriber&lt;Integer&gt; sub = AssertSubscriber.create();\n\nsub = Multi.createFrom().range(0, 100)\n        .capDemandsUsing(n -&gt; {\n            if (n &gt; 1) {\n                return (long) (((double) n) * 0.75d);\n            } else {\n                return n;\n            }\n        })\n        .subscribe().withSubscriber(sub);\n\nsub.request(100L).assertNotTerminated();\nassertThat(sub.getItems()).hasSize(75);\n\nsub.request(1L).assertNotTerminated();\nassertThat(sub.getItems()).hasSize(94);\n\nsub.request(Long.MAX_VALUE).assertCompleted();\nassertThat(sub.getItems()).hasSize(100);\n</code></pre> <p>Here we have a function that requests 75% of the downstream requests.</p> <p>Note that the function must return a value <code>n</code> that satisfies <code>(0 &lt; n &lt;= requested)</code> where <code>requested</code> is the downstream demand.</p>","tags":["guide","advanced"]},{"location":"guides/converters/","title":"Using other reactive programming libraries","text":"<p>You may need to integrate libraries exposing an API using other reactive programming libraries such as RX Java or Reactor. Mutiny has a built-in conversion mechanism to ease that integration.</p>","tags":["guide","advanced"]},{"location":"guides/converters/#picking-the-right-dependency","title":"Picking the right dependency","text":"<p>You need to add another dependency to access the converters. Each artifact contains the converters for a specific reactive library. Pick the right one and add it to your project:</p> ReactorRxJava 3 <pre><code>&lt;!-- Mutiny &lt;-&gt; Reactor --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;\n    &lt;artifactId&gt;mutiny-reactor&lt;/artifactId&gt;\n    &lt;version&gt;2.8.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>&lt;!-- Mutiny &lt;-&gt; RX Java 3 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;\n    &lt;artifactId&gt;mutiny-rxjava3&lt;/artifactId&gt;\n    &lt;version&gt;2.8.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/converters/#integration-with-project-reactor","title":"Integration with Project Reactor","text":"<p>Project Reactor is a popular reactive programming library. It offers two types: <code>Mono</code> and <code>Flux,</code> both implementing Reactive Stream <code>Publisher</code>.</p> <p>To use the Reactor <code>&lt;-&gt;</code> Mutiny converter, add the following imports to your class:</p> <pre><code>import io.smallrye.mutiny.converters.multi.MultiReactorConverters;\nimport io.smallrye.mutiny.converters.uni.UniReactorConverters;\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/converters/#converting-a-flux-or-a-mono-into-a-multi","title":"Converting a Flux or a Mono into a Multi","text":"<p>Both <code>Flux</code> and <code>Mono</code> implement <code>Publisher</code>. As a result, we can use the Reactive Streams interoperability to convert instances from <code>Flux&lt;T&gt;</code> and <code>Mono&lt;T&gt;</code> to <code>Multi&lt;T&gt;</code>:</p> <pre><code>Flow.Publisher&lt;T&gt; fluxAsPublisher = AdaptersToFlow.publisher(flux);\nMulti&lt;T&gt; multiFromFlux = Multi.createFrom().publisher(fluxAsPublisher);\n\nFlow.Publisher&lt;T&gt; monoAsPublisher = AdaptersToFlow.publisher(mono);\nMulti&lt;T&gt; multiFromMono = Multi.createFrom().publisher(monoAsPublisher);\n</code></pre> <p>Attention</p> <p>Reactor still uses the legacy Reactive Streams APIs instead of <code>java.util.concurrent.Flow</code>, so you need to perform an adaptation.</p> <p>We recommend using the Mutiny Zero Flow Adapters library as in these examples (Maven coordinates <code>io.smallrye.reactive:mutiny-zero-flow-adapters</code>).</p>","tags":["guide","advanced"]},{"location":"guides/converters/#converting-a-flux-or-a-mono-into-a-uni","title":"Converting a Flux or a Mono into a Uni","text":"<p>As you can create <code>Uni</code> from a <code>Publisher</code>, the same approach can be used to create <code>Uni</code> instances:</p> <pre><code>Flow.Publisher&lt;T&gt; fluxAsPublisher = AdaptersToFlow.publisher(flux);\nUni&lt;T&gt; uniFromFlux = Uni.createFrom().publisher(fluxAsPublisher);\n\nFlow.Publisher&lt;T&gt; monoAsPublisher = AdaptersToFlow.publisher(mono);\nUni&lt;T&gt; uniFromMono = Uni.createFrom().publisher(monoAsPublisher);\n</code></pre> <p>When a <code>Flux</code> or <code>Mono</code> sends the completion event without having emitted any item, the resulting <code>Uni</code> emits <code>null</code>.</p> <p>When converting a <code>Flux</code> to <code>Uni</code>, the resulting <code>Uni</code> emits the first item. After that emission, it cancels the subscription to the <code>Flux</code>.</p>","tags":["guide","advanced"]},{"location":"guides/converters/#converting-a-multi-into-a-flux-or-mono","title":"Converting a Multi into a Flux or Mono","text":"<p>Converting a <code>Multi</code> into a <code>Flux</code> or a <code>Mono</code> uses the Reactive Streams interoperability:</p> <pre><code>Publisher&lt;T&gt; multiAsLegacyPublisher = AdaptersToReactiveStreams.publisher(multi);\n\nFlux&lt;T&gt; fluxFromMulti = Flux.from(multiAsLegacyPublisher);\nMono&lt;T&gt; monoFromMulti = Mono.from(multiAsLegacyPublisher);\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/converters/#converting-a-uni-into-a-flux-or-mono","title":"Converting a Uni into a Flux or Mono","text":"<p>Converting a <code>Uni</code> into a <code>Flux</code> or a <code>Mono</code> requires a converter, as <code>Uni</code> does not implement Reactive Streams.</p> <pre><code>Flux&lt;T&gt; fluxFromUni = uni.convert().with(UniReactorConverters.toFlux());\nMono&lt;T&gt; monoFromUni = uni.convert().with(UniReactorConverters.toMono());\n</code></pre> <p>If the <code>Uni</code> emits <code>null</code>, it sends the completion event.</p>","tags":["guide","advanced"]},{"location":"guides/converters/#using-converter-instead-of-reactive-streams","title":"Using converter instead of Reactive Streams","text":"<p>While Reactive Streams interoperability is convenient, Mutiny also provides converters to create <code>Flux</code> and <code>Mono</code> from <code>Uni</code> and <code>Multi</code>:</p> <pre><code>Mono&lt;String&gt; mono = uni.convert().with(UniReactorConverters.toMono());\nFlux&lt;String&gt; flux = uni.convert().with(UniReactorConverters.toFlux());\n\nMono&lt;String&gt; mono = multi.convert().with(MultiReactorConverters.toMono());\nFlux&lt;String&gt; flux = multi.convert().with(MultiReactorConverters.toFlux());\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/converters/#integration-with-rx-java-3","title":"Integration with RX Java 3","text":"<p>RxJava is another popular reactive programming library. It offers 5 types: <code>Completable</code> (no item), <code>Single</code> (one item), <code>Maybe</code> (0 or 1 item), <code>Observable</code> (multiple items), <code>Flowable</code> (multiple items, implements Reactive Stream <code>Publisher</code>).</p> <p>To use the RxJava <code>&lt;-&gt;</code> Mutiny converters, add the following imports to your class:</p> <pre><code>import io.smallrye.mutiny.converters.multi.MultiRx3Converters;\nimport io.smallrye.mutiny.converters.uni.UniRx3Converters;\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/converters/#converting-an-observable-or-a-flowable-into-a-multi","title":"Converting an Observable or a Flowable into a Multi","text":"<p>Both <code>Observable</code> and <code>Flowable</code> are item streams. However, <code>Observable</code> does not implement <code>Publisher</code> and so does not have back-pressure support.</p> <p>To create <code>Multi</code> from an <code>Observable,</code> you need a specific converter:</p> <pre><code>Multi&lt;T&gt; multiFromObservable = Multi.createFrom()\n        .converter(MultiRx3Converters.fromObservable(), observable);\n</code></pre> <p>Converting a <code>Flowable</code> is easier, as it\u2019s a <code>Publisher</code>:</p> <pre><code>Flow.Publisher&lt;T&gt; flowableAsPublisher = AdaptersToFlow.publisher(flowable);\n\nMulti&lt;T&gt; multiFromFlowable = Multi.createFrom().publisher(flowableAsPublisher);\n</code></pre> <p>Attention</p> <p>Like Reactor, RxJava still uses the legacy Reactive Streams APIs instead of <code>java.util.concurrent.Flow</code>, so you need to perform an adaptation.</p>","tags":["guide","advanced"]},{"location":"guides/converters/#converting-a-completable-single-or-maybe-into-a-multi","title":"Converting a Completable, Single or Maybe into a Multi","text":"<p>To create a <code>Multi</code> from a <code>Completable,</code> <code>Single</code> or <code>Maybe</code> you need specific converters, as none of these types implement Reactive Streams.</p> <pre><code>Multi&lt;Void&gt; multiFromCompletable = Multi.createFrom()\n        .converter(MultiRx3Converters.fromCompletable(), completable);\nMulti&lt;T&gt; multiFromSingle = Multi.createFrom()\n        .converter(MultiRx3Converters.fromSingle(), single);\nMulti&lt;T&gt; multiFromMaybe = Multi.createFrom()\n        .converter(MultiRx3Converters.fromMaybe(), maybe);\nMulti&lt;T&gt; multiFromEmptyMaybe = Multi.createFrom()\n        .converter(MultiRx3Converters.fromMaybe(), emptyMaybe);\n</code></pre> <ul> <li>Creating a <code>Multi</code> from a <code>Completable</code> always produces a <code>Multi&lt;Void&gt;</code> that only emits the completion or failure event.</li> <li>Creating a <code>Multi</code> from a <code>Single</code> produces a <code>Multi</code>. That <code>Multi</code> emits the item and then completes it.</li> <li>Creating a <code>Multi</code> from a <code>Maybe</code> produces a <code>Multi</code>. That <code>Multi</code>  emits the item (if any) and then completes it.   If the <code>Maybe</code> is empty, then the created <code>Multi</code> emits the completion event.</li> </ul> <p>When a <code>Completable,</code> <code>Single,</code> or <code>Maybe</code> emits a failure, then the resulting <code>Multi</code> emits that failure.</p>","tags":["guide","advanced"]},{"location":"guides/converters/#converting-an-observable-or-a-flowable-into-a-uni","title":"Converting an Observable or a Flowable into a Uni","text":"<p>To create a <code>Uni</code> from an <code>Observable,</code> you need to use a specific converter:</p> <pre><code>Uni&lt;T&gt; uniFromObservable = Uni.createFrom().converter(\n        UniRx3Converters.fromObservable(), observable);\n</code></pre> <p>The creation from a <code>Flowable</code> can be done using the Reactive Streams interoperability:</p> <pre><code>Flow.Publisher&lt;T&gt; flowableAsPublisher = AdaptersToFlow.publisher(flowable);\n\nUni&lt;T&gt; uniFromFlowable = Uni.createFrom().publisher(flowableAsPublisher);\n</code></pre> <p>In both cases, it cancels the subscription to the <code>Flowable</code> or <code>Observable</code> after receiving the first item. If the <code>Flowable</code> or <code>Observable</code> completes without items, the <code>Uni</code> emits a <code>null</code> item.</p>","tags":["guide","advanced"]},{"location":"guides/converters/#converting-a-completable-single-or-maybe-into-a-uni","title":"Converting a Completable, Single or Maybe into a Uni","text":"<p>To create a <code>Uni</code> from a <code>Completable,</code> <code>Single,</code> or <code>Maybe</code>, you need to use a specific converter:</p> <pre><code>Uni&lt;Void&gt; multiFromCompletable = Uni.createFrom()\n        .converter(UniRx3Converters.fromCompletable(), completable);\nUni&lt;T&gt; multiFromSingle = Uni.createFrom()\n        .converter(UniRx3Converters.fromSingle(), single);\nUni&lt;T&gt; multiFromMaybe = Uni.createFrom()\n        .converter(UniRx3Converters.fromMaybe(), maybe);\nUni&lt;T&gt; multiFromEmptyMaybe = Uni.createFrom()\n        .converter(UniRx3Converters.fromMaybe(), emptyMaybe);\n</code></pre> <p>Converting a <code>Completable</code> to a <code>Uni</code> always produces a <code>Uni&lt;Void&gt;,</code> that emits either <code>null</code> once the <code>Completable</code> completes or the failure if it fails. The <code>Maybe</code> to <code>Uni</code> conversion emits a <code>null</code> item if the <code>Maybe</code> completes without an item.</p>","tags":["guide","advanced"]},{"location":"guides/converters/#converting-a-multi-into-a-rx-java-objects","title":"Converting a Multi into a RX Java objects","text":"<p>The conversion from a <code>Multi</code> to the various RX Java objects is done using converters:</p> <pre><code>Completable completable = multi.convert()\n        .with(MultiRx3Converters.toCompletable());\nSingle&lt;Optional&lt;T&gt;&gt; single = multi.convert()\n        .with(MultiRx3Converters.toSingle());\nSingle&lt;T&gt; single2 = multi.convert()\n        .with(MultiRx3Converters\n                .toSingle().onEmptyThrow(() -&gt; new Exception(\"D'oh!\")));\nMaybe&lt;T&gt; maybe = multi.convert()\n        .with(MultiRx3Converters.toMaybe());\nObservable&lt;T&gt; observable = multi.convert()\n        .with(MultiRx3Converters.toObservable());\nFlowable&lt;T&gt; flowable = multi.convert()\n        .with(MultiRx3Converters.toFlowable());\n</code></pre> <p>The creation of a <code>Completable</code> from a <code>Multi</code> discards all the items emitted by the <code>Multi</code>. It only forwards the completion or failure event.</p> <p>Converting a <code>Multi</code> into a <code>Single</code> returns a <code>Single&lt;Optional&lt;T&gt;&gt;,</code> as the <code>Multi</code> may complete without items. You can also produce a <code>Single&lt;T&gt;</code> and emit a failure event if the <code>Multi</code> completes without items. You can configure the thrown exception using <code>onEmptyThrow.</code></p> <p>Tip</p> <p>You can also create a <code>Flowable</code> from a <code>Multi</code> using: <code>Flowable.fromPublisher(multi)</code>.</p>","tags":["guide","advanced"]},{"location":"guides/converters/#converting-a-uni-into-a-rx-java-type","title":"Converting a Uni into a RX Java type","text":"<p>Similarly to the conversion from a <code>Multi</code> into an RX Type, converting a <code>Uni</code> requires a converter:</p> <pre><code>Completable completable = uni.convert().with(UniRx3Converters.toCompletable());\nSingle&lt;Optional&lt;T&gt;&gt; single = uni.convert().with(UniRx3Converters.toSingle());\nSingle&lt;T&gt; single2 = uni.convert().with(UniRx3Converters.toSingle().failOnNull());\nMaybe&lt;T&gt; maybe = uni.convert().with(UniRx3Converters.toMaybe());\nObservable&lt;T&gt; observable = uni.convert().with(UniRx3Converters.toObservable());\nFlowable&lt;T&gt; flowable = uni.convert().with(UniRx3Converters.toFlowable());\n</code></pre> <p>The creation of a <code>Completable</code> from a <code>Uni</code> discards the item and sends the completion signal after emission.</p> <p>Converting a <code>Uni</code> into a <code>Single</code> returns a <code>Single&lt;Optional&lt;T&gt;&gt;,</code> as the <code>Uni</code> may emit <code>null.</code> You can also produce a <code>Single&lt;T&gt;</code> and emits a failure event if the <code>Uni</code> sends <code>null.</code> Configure the failure to forward using <code>failOnNull.</code></p> <p>The creation of a <code>Maybe,</code> <code>Flowable,</code> or an <code>Observable</code> from a <code>Uni</code> produces an empty <code>Maybe,</code> <code>Flowable,</code> or <code>Observable</code> if the <code>Uni</code> emits <code>null.</code> For <code>Flowable</code> and <code>Observable,</code> if the <code>Uni</code> emits a non-null item, that item is emitted, followed immediately by the completion signal.</p>","tags":["guide","advanced"]},{"location":"guides/custom-operators/","title":"Can I have custom operators?","text":"<p>Yes, but please write operators responsibly!</p> <p>Both <code>Uni</code> and <code>Multi</code> support custom operators using the <code>plug</code> operator. Here is an example where we use a custom <code>Multi</code> operator that randomly drops items:</p> <pre><code>Multi.createFrom()\n        .range(1, 101)\n        .plug(RandomDrop::new)\n        .subscribe().with(System.out::println);\n</code></pre> <p>with the operator defined as follows:</p> <pre><code>public class RandomDrop&lt;T&gt; extends AbstractMultiOperator&lt;T, T&gt; {\n    public RandomDrop(Multi&lt;? extends T&gt; upstream) {\n        super(upstream);\n    }\n\n    @Override\n    public void subscribe(MultiSubscriber&lt;? super T&gt; downstream) {\n        upstream.subscribe().withSubscriber(new DropProcessor(downstream));\n    }\n\n    private class DropProcessor extends MultiOperatorProcessor&lt;T, T&gt; {\n        DropProcessor(MultiSubscriber&lt;? super T&gt; downstream) {\n            super(downstream);\n        }\n\n        @Override\n        public void onItem(T item) {\n            if (ThreadLocalRandom.current().nextBoolean()) {\n                super.onItem(item);\n            }\n        }\n    }\n}\n</code></pre> <p>Caution</p> <p>Custom operators are an advanced feature: when possible please use the existing operators and use helpers such as <code>stage</code> to write readable code.</p> <p>In the case of custom <code>Multi</code> operators it is wise to test them against the Reactive Streams TCK.</p>","tags":["guide","advanced"]},{"location":"guides/delaying-events/","title":"How to delay events?","text":"","tags":["guide","intermediate"]},{"location":"guides/delaying-events/#delaying-unis-item","title":"Delaying Uni\u2019s item","text":"<p>When you have a <code>Uni</code>, you can delay the item emission using <code>onItem().delayIt().by(...)</code>:</p> <pre><code>Uni&lt;String&gt; delayed = Uni.createFrom().item(\"hello\")\n        .onItem().delayIt().by(Duration.ofMillis(10));\n</code></pre> <p>You pass a duration. When the item is received, it waits for  that duration before propagating it to the downstream consumer.</p> <p>You can also delay the item\u2019s emission based on another companion <code>Uni</code>:</p> <pre><code>Uni&lt;String&gt; delayed = Uni.createFrom().item(\"hello\")\n        // The write method returns a Uni completed\n        // when the operation is done.\n        .onItem().delayIt().until(this::write);\n</code></pre> <p>The item is propagated downstream when the <code>Uni</code> returned by the function emits an item (possibly <code>null</code>). If the function emits a failure (or throws an exception), this failure is propagated downstream.</p>","tags":["guide","intermediate"]},{"location":"guides/delaying-events/#throttling-a-multi","title":"Throttling a Multi","text":"<p>Multi does not have a delayIt operator because applying the same delay to all items is rarely what you want to do. However, there are several ways to apply a delay in a <code>Multi</code>.</p> <p>First, you can use the <code>onItem().call()</code>, which delays the emission until the <code>Uni</code> produced the <code>call</code> emits an item. For example, the following snippet delays all the items by 10 ms:</p> <pre><code>Multi&lt;Integer&gt; delayed = multi\n    .onItem().call(i -&gt;\n        // Delay the emission until the returned uni emits its item\n        Uni.createFrom().nullItem().onItem().delayIt().by(Duration.ofMillis(10))\n    );\n</code></pre> <p>In general, you don\u2019t want to apply the same delay to all the items. You can combine <code>call</code> with a random delay as follows:</p> <pre><code>Random random = new Random();\nMulti&lt;Integer&gt; delayed = Multi.createFrom().items(1, 2, 3, 4, 5)\n        .onItem().call(i -&gt; {\n            Duration delay = Duration.ofMillis(random.nextInt(100) + 1);\n            return Uni.createFrom().nullItem().onItem().delayIt().by(delay);\n        });\n</code></pre> <p>Finally, you may want to throttle the items. For example, you can introduce a (minimum) one-second delay between each item. To achieve this, combine <code>Multi.createFrom().ticks()</code> and the multi to throttled:</p> <pre><code>// Introduce a one second delay between each item\nMulti&lt;Long&gt; ticks = Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n        .onOverflow().drop();\nMulti&lt;Integer&gt; delayed = Multi.createBy().combining().streams(ticks, multi)\n        .using((x, item) -&gt; item);\n</code></pre> <p>Tip</p> <p>The <code>onOverflow().drop()</code> is used to avoid the ticks to fail if the other stream (<code>multi</code>) is too slow.</p>","tags":["guide","intermediate"]},{"location":"guides/delaying-events/#delaying-other-types-of-events","title":"Delaying other types of events","text":"<p>We have looked at how to delay items, but you may need to delay other events, such as subscription or failure. For these, use the <code>call</code> approach, and return a <code>Uni</code> that delay the event\u2019s propagation.</p>","tags":["guide","intermediate"]},{"location":"guides/dropped-exceptions/","title":"How to deal with dropped exceptions?","text":"<p>There are a few corner cases where Mutiny cannot propagate an exception to a <code>Uni</code> or a <code>Multi</code> subscriber.</p> <p>Consider the following example:</p> <pre><code>Cancellable cancellable = Uni.createFrom()\n        .emitter(this::emitter)\n        .onCancellation().call(() -&gt; Uni.createFrom().failure(new IOException(\"boom\")))\n        .subscribe().with(this::onItem, this::onFailure);\n\ncancellable.cancel();\n</code></pre> <p>The <code>onCancellation().call(...)</code> method is called when the <code>Uni</code> subscription is cancelled. The returned <code>Uni</code> is failed with a <code>IOException</code>, but since the subscription itself has been cancelled then there is no way to catch the exception.</p> <p>By default Mutiny reports such dropped exceptions to the standard error stream along with the corresponding stack trace. You can change how these exceptions are handled using <code>Infrastructure.setDroppedExceptionHandler</code>.</p> <p>The following logs dropped exceptions to a logger:</p> <pre><code>Infrastructure.setDroppedExceptionHandler(err -&gt;\n        log(Level.SEVERE, \"Mutiny dropped exception\", err)\n);\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/eliminate-duplicates-and-repetitions/","title":"Eliminate duplicates and repetitions","text":"<p>When observing a <code>Multi</code>, you may see duplicated items or repetitions. The <code>multi.select()</code> and <code>multi.skip()</code> groups provide methods to only select distinct items or drop repetitions.</p>","tags":["guide","beginner"]},{"location":"guides/eliminate-duplicates-and-repetitions/#selecting-distinct","title":"Selecting distinct","text":"<p>The <code>.select().distinct()</code> operator removes all the duplicates. As a result, the downstream only contains distinct items:</p> <pre><code>List&lt;Integer&gt; list = multi\n        .select().distinct()\n        .collect().asList()\n        .await().indefinitely();\n</code></pre> <p>If you have a stream emitting the <code>{1, 1, 2, 3, 4, 5, 5, 6, 1, 4, 4}</code> items, then applying <code>.select().distinct()</code> on such a stream produces: <code>{1, 2, 3, 4, 5, 6}</code>.</p> <p>Important</p> <p>The operator keeps a reference on all the emitted items, and so, it could lead to memory issues if the stream contains too many distinct items.</p> <p>Tip</p> <p>By default, <code>select().distinct()</code> uses the <code>hashCode</code> method from the item\u2019s class. You can pass a custom comparator for more advanced checks.</p> <p>If you have a stream emitting items of type <code>T</code>, where duplicates can be identified through an attribute of <code>T</code> of type <code>K</code>, then an <code>extractor</code> of type <code>Function&lt;T, K&gt;</code> can be defined. Applying <code>.select().distinct(extractor)</code> on such a stream will eliminate duplicates but have a lesser memory overhead as only the references to the extracted keys need to be kept, not the whole object. A typical usage of this might be for a stream of records where uniqueness is determined by a UUID assigned to every record.</p>","tags":["guide","beginner"]},{"location":"guides/eliminate-duplicates-and-repetitions/#skipping-repetitions","title":"Skipping repetitions","text":"<p>The <code>.skip().repetitions()</code> operator removes subsequent repetitions of an item:</p> <pre><code>List&lt;Integer&gt; list2 = multi\n        .skip().repetitions()\n        .collect().asList()\n        .await().indefinitely();\n</code></pre> <p>If you have a stream emitting the <code>{1, 1, 2, 3, 4, 5, 5, 6, 1, 4, 4}</code> items, then applying <code>.skip().repetitions()</code> on such a stream produces: <code>{1, 2, 3, 4, 5, 6, 1, 4}</code>.</p> <p>Unlike <code>.select().distinct()</code>, you can use this operator on large or infinite streams.</p> <p>Tip</p> <p>By default, <code>skip().repetitions()</code> uses the <code>equals</code> method from the item\u2019s class. You can pass a custom comparator for more advanced checks.</p>","tags":["guide","beginner"]},{"location":"guides/emission-threads/","title":"How to change the emission thread?","text":"<p>Except indicated otherwise, Mutiny invokes the next stage using the thread emitting the event from upstream. So, in the following code, the transform stage is invoked from the thread emitting the event.</p> <pre><code>Uni&lt;String&gt; uni = Uni.createFrom().&lt;String&gt;emitter(emitter -&gt;\n        new Thread(() -&gt;\n                emitter.complete(\"hello from \"\n                        + Thread.currentThread().getName())\n        ).start()\n)\n        .onItem().transform(item -&gt; {\n            // Called on the emission thread.\n            return item.toUpperCase();\n        });\n</code></pre> <p>You can switch to another thread using the <code>emitOn</code> operator. The <code>emitOn</code> operator lets you switch the thread used to dispatch (upstream -&gt; downstream) events, so items, failure and completion events. Just pass the executor you want to use.</p> <pre><code>String res0 = uni.emitOn(executor)\n        .onItem()\n        .invoke(s -&gt; System.out.println(\"Received item `\" + s + \"` on thread: \"\n                + Thread.currentThread().getName()))\n        .await().indefinitely();\n\nString res1 = multi.emitOn(executor)\n        .onItem()\n        .invoke(s -&gt; System.out.println(\"Received item `\" + s + \"` on thread: \"\n                + Thread.currentThread().getName()))\n        .collect().first()\n        .await().indefinitely();\n</code></pre> <p>Note</p> <p>You cannot pass a specific thread, but you can implement a simple <code>Executor</code> dispatching on that specific thread, or use a single threaded executor.</p> <p>Warning</p> <p>Be careful as this operator can lead to concurrency problems with non thread-safe objects such as CDI request-scoped beans. It might also break reactive-streams semantics with items being emitted concurrently.</p>","tags":["guide","intermediate"]},{"location":"guides/emit-on-vs-run-subscription-on/","title":"What is the difference between emitOn and runSubscriptionOn?","text":"<p>The <code>emitOn</code> and <code>runSubscriptionOn</code> are 2 operators influencing on which threads the event are dispatched. However, they target different types of events and different directions.</p>","tags":["guide","intermediate"]},{"location":"guides/emit-on-vs-run-subscription-on/#the-case-of-emiton","title":"The case of emitOn","text":"<p><code>emitOn</code> takes events coming from upstream (items, completion, failure) and replays them downstream on a thread from the given executor. Consequently, it affects where the subsequent operators execute (until another <code>emitOn</code> is used):</p> <pre><code>Multi.createFrom().items(this::retrieveItemsFromSource)\n        .emitOn(executor)\n        .onItem().transform(this::applySomeOperation)\n        .subscribe().with(\n        item -&gt; System.out.println(\"Item: \" + item),\n        Throwable::printStackTrace,\n        () -&gt; completed.set(true)\n);\n</code></pre> <p>The previous code produces the following sequence:</p> <pre><code>sequenceDiagram\n    autonumber\n    participant M as Multi\n    participant O as emitOn(executor)\n    participant D as Subscriber\n\n    M-&gt;&gt;O: onItem(1)\n    Note right of M: On caller thread\n\n    O-&gt;&gt;D: onItem(1)\n    Note right of O: On executor thread</code></pre> <p>Warning</p> <p>Be careful as this operator can lead to concurrency problems with non thread-safe objects such as CDI request-scoped beans. It might also break reactive-streams semantics with items being emitted concurrently.</p>","tags":["guide","intermediate"]},{"location":"guides/emit-on-vs-run-subscription-on/#the-case-of-runsubscriptionon","title":"The case of runSubscriptionOn","text":"<p><code>runSubscriptionOn</code> applies to the subscription process. It requests the upstream to run its subscription (call of the <code>subscribe</code> method on its own upstream) on a thread from the given executor:</p> <pre><code>Multi.createFrom().items(() -&gt; {\n    // called on a thread from the executor\n    return retrieveItemsFromSource();\n})\n        .onItem().transform(this::applySomeOperation)\n        .runSubscriptionOn(executor)\n        .subscribe().with(\n        item -&gt; System.out.println(\"Item: \" + item),\n        Throwable::printStackTrace,\n        () -&gt; completed.set(true)\n);\n</code></pre> <p>So, if we consider the previous code snippet, it produces the following sequence:</p> <pre><code>sequenceDiagram\n    autonumber\n    participant M as Multi\n    participant O as runSubscriptionOn(executor)\n    participant D as Subscriber\n\n    D-&gt;&gt;O: subscribe\n    Note right of O: on Caller thread\n\n    O-&gt;&gt;M: subscribe\n    Note right of M: On executor thread</code></pre>","tags":["guide","intermediate"]},{"location":"guides/filtering-items/","title":"Filtering items from Multi","text":"<p>When observing a <code>Multi</code>, you may not want to forward all the received items to the downstream.</p> <p>Use the <code>multi.select()</code> group to select items.</p> <pre><code>List&lt;Integer&gt; list = multi\n        .select().where(i -&gt; i &gt; 6)\n        .collect().asList()\n        .await().indefinitely();\n</code></pre> <p>To select items passing a given predicate, use <code>multi.select().where(predicate)</code>:</p> <p><code>where</code> accepts a predicate called for each item. If the predicate returns <code>true</code>, the item propagated downstream. Otherwise, it drops the item.</p> <p>The predicate passed to <code>where</code> is synchronous. The <code>when</code> method provides an asynchronous version:</p> <pre><code>List&lt;Integer&gt; list2 = multi\n        .select().when(i -&gt; Uni.createFrom().item(i &gt; 6))\n        .collect().asList()\n        .await().indefinitely();\n</code></pre> <p><code>when</code> accepts a function called for each item.</p> <p>Unlike <code>where</code> where the predicate returns a boolean synchronously, the function returns a <code>Uni&lt;Boolean&gt;</code>. It forwards the item downstream if the <code>uni</code> produced by the function emits <code>true</code>. Otherwise, it drops the item.</p>","tags":["guide","beginner"]},{"location":"guides/framework-integration/","title":"How can I integrate Mutiny with my framework?","text":"<p>Sometimes, Mutiny needs to execute tasks on other threads, such as monitoring time or delaying actions. Most operators relying on such capacity let you pass either a <code>ScheduledExecutorService</code> or an <code>ExecutorService</code>.</p> <p>By default, Mutiny uses the a cached thread pool as default executor, that creates new threads as needed, but reuse previously constructed threads when they are available. A <code>ScheduledExecutorService</code> is also created but delegates the execution of the delayed/scheduled tasks to the default executor.</p> <p>In the case you want to integrate Mutiny with a thread pool managed by a platform, you can configure it using <code>Infrastructure.setDefaultExecutor()</code> method:</p> <pre><code>Uni&lt;Integer&gt; uni1 = Uni.createFrom().item(1)\n        .emitOn(Infrastructure.getDefaultExecutor());\n\nUni&lt;Integer&gt; uni2 = Uni.createFrom().item(2)\n        .onItem().delayIt()\n            .onExecutor(Infrastructure.getDefaultWorkerPool())\n            .by(Duration.ofMillis(10));\n</code></pre> <p>You can configure the default executor using the <code>Infrastructure.setDefaultExecutor</code> method:</p> <pre><code>Infrastructure.setDefaultExecutor(executor);\n</code></pre> <p>Tip</p> <p>If you are using Quarkus, the default executor is already configured to use the Quarkus worker thread pool. Logging is also configured correctly.</p>","tags":["guide","advanced"]},{"location":"guides/handling-null/","title":"How to handle null?","text":"<p>The <code>Uni</code> type can emit <code>null</code> as item.</p> <p>While there are mixed feelings about <code>null</code>, it\u2019s part of the Java language and so handled in the <code>Uni</code> type.</p> <p>Important</p> <p><code>Multi</code> does not support <code>null</code> items as it would break the compatibility with the Reactive Streams protocol.</p> <p>Emitting <code>null</code> is convenient when returning <code>Uni&lt;Void&gt;</code>. However, the downstream must expect <code>null</code> as item.</p> <p>Thus, <code>Uni</code> provides specific methods to handle <code>null</code> item. <code>uni.onItem().ifNull()</code> lets you decide what you want to do when the received item is <code>null</code>:</p> <pre><code>uni.onItem().ifNull().continueWith(\"hello\");\nuni.onItem().ifNull().switchTo(() -&gt; Uni.createFrom().item(\"hello\"));\nuni.onItem().ifNull().failWith(() -&gt; new Exception(\"Boom!\"));\n</code></pre> <p>A symmetric group of methods is also available with <code>ifNotNull</code> which let you handle the case where the item is not null:</p> <pre><code>uni\n    .onItem().ifNotNull().transform(String::toUpperCase)\n    .onItem().ifNull().continueWith(\"yolo!\");\n</code></pre> <p>Important</p> <p>While supported, emitting <code>null</code> should be avoided except for <code>Uni&lt;Void&gt;</code>.</p>","tags":["guide","beginner"]},{"location":"guides/handling-timeouts/","title":"How to handle timeouts?","text":"<p>Unis are often used to represent asynchronous operations, like making an HTTP call. So, it\u2019s not rare to need to add a timeout or a deadline on this kind of operation. If we don\u2019t get a response (receive an item in the Mutiny lingo) before that deadline, we consider that the operation failed.</p> <p>We can then recover from this failure by using a fallback value, retrying, or any other failure handling strategy.</p> <p>To configure a timeout use <code>Uni.ifNoItem().after(Duration)</code>:</p> <pre><code>Uni&lt;String&gt; uniWithTimeout = uni\n        .ifNoItem().after(Duration.ofMillis(100))\n        .recoverWithItem(\"some fallback item\");\n</code></pre> <p>When the deadline is reached, you can do various actions. First you can simply fail:</p> <pre><code>Uni&lt;String&gt; uniWithTimeout = uni\n        .ifNoItem().after(Duration.ofMillis(100)).fail();\n</code></pre> <p>A <code>TimeoutException</code> is propagated in this case. So you can handle it specifically in the downstream:</p> <pre><code>Uni&lt;String&gt; uniWithTimeout = uni\n    .ifNoItem().after(Duration.ofMillis(100)).fail()\n    .onFailure(TimeoutException.class).recoverWithItem(\"we got a timeout\");\n</code></pre> <p>You can also pass a custom exception:</p> <pre><code>Uni&lt;String&gt; uniWithTimeout = uni\n    .ifNoItem().after(Duration.ofMillis(100)).failWith(() -&gt; new ServiceUnavailableException());\n</code></pre> <p>Failing and recovering might be inconvenient. So, you can pass a fallback item or <code>Uni</code> directly:</p> <pre><code>Uni&lt;String&gt; uniWithTimeout = uni\n        .ifNoItem().after(Duration.ofMillis(100)).recoverWithItem(() -&gt; \"fallback\");\n</code></pre> <pre><code>Uni&lt;String&gt; uniWithTimeout = uni\n        .ifNoItem().after(Duration.ofMillis(100)).recoverWithUni(() -&gt; someFallbackUni());\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/hot-streams/","title":"Hot streams","text":"<p>In a cold stream, the stream is created when one subscriber subscribes to the stream. So, if no one subscribes, the actual stream is not created, saving resources (that would be wasted because nobody is interested in the items).</p> <p>In a hot stream, the stream exists before subscribers subscribe. The stream emits items even if no subscribers observe the stream. If there are no subscribers, the items are just dropped. Subscribers only get items emitted after their subscription, meaning that any previous items would not be received.</p> <p>To create a hot stream, you can use <code>io.smallrye.mutiny.operators.multi.processors.BroadcastProcessor</code> that:</p> <ul> <li>drops items if no subscribers are present,</li> <li>forwards items to the set of observing subscribers.</li> </ul> <pre><code>BroadcastProcessor&lt;String&gt; processor = BroadcastProcessor.create();\nMulti&lt;String&gt; multi = processor\n        .onItem().transform(String::toUpperCase)\n        .onFailure().recoverWithItem(\"d'oh\");\n\nnew Thread(() -&gt; {\n    for (int i = 0; i &lt; 1000; i++) {\n        processor.onNext(Integer.toString(i));\n    }\n    processor.onComplete();\n}).start();\n\n// Subscribers can subscribe at any time.\n// They will only receive items emitted after their subscription.\n// If the source is already terminated (by a completion or a failure signal)\n// the subscriber receives this signal.\n</code></pre> <p>Note that the <code>BroadcastProcessor</code> subscribes to the hot source aggressively and without back-pressure. However, the <code>BroadcastProcessor</code> enforces the back-pressure protocol per subscriber. If a subscriber is not ready to handle an item emitted by the hot source, an <code>io.smallrye.mutiny.subscription.BackPressureFailure</code> is forwarded to this subscriber.</p>","tags":["guide","advanced"]},{"location":"guides/imperative-to-reactive/","title":"From imperative to reactive","text":"<p>If you use Mutiny, there is a good chance you may want to avoid blocking the caller thread.</p> <p>In a pure reactive application, the application logic is executed on one of the few I/O threads, and blocking one of these would have dramatic consequences. So, here is the big question: how do you deal with blocking code?</p> <p>Let\u2019s imagine you have blocking code (e.g., connecting to a database using JDBC, reading a file from the file system\u2026), and you want to integrate that into your reactive pipelines while avoiding blocking. You would need to isolate such blocking parts of your code and run these parts on worker threads.</p> <p>Mutiny provides two operators to customize the threads used to handle events:</p> <ul> <li><code>runSubscriptionOn</code> - to configure the thread used to execute the code happening at subscription-time</li> <li><code>emitOn</code> - to configure the thread used to dispatch events downstream</li> </ul>","tags":["guide","advanced"]},{"location":"guides/imperative-to-reactive/#running-blocking-code-on-subscription","title":"Running blocking code on subscription","text":"<p>It is very usual to deal with the blocking call during the subscription. In this case, the <code>runSubscription</code> operator is what you need:</p> <pre><code>Uni&lt;String&gt; uni = Uni.createFrom()\n        .item(this::invokeRemoteServiceUsingBlockingIO)\n        .runSubscriptionOn(Infrastructure.getDefaultWorkerPool());\n</code></pre> <p>The code above creates a Uni that will supply the item using a blocking call, here the <code>invokeRemoteServiceUsingBlockingIO</code> method. To avoid blocking the subscriber thread, it uses <code>runSubscriptionOn</code> which switches the thread and call <code>invokeRemoteServiceUsingBlockingIO</code> on another thread. Here we pass the default worker thread pool, but you can use your own executor.</p> <p>Tip</p> <p>What\u2019s that default worker pool?</p> <p>In the previous snippet, you may wonder about <code>Infrastructure.getDefaultWorkerPool()</code>. Mutiny allows the underlying platform to provide a default worker pool. <code>Infrastructure.getDefaultWorkerPool()</code> provides access to this pool.</p> <p>If the underlying platform does not provide a pool, a default one is used.</p> <p>Note that <code>runSubscriptionOn</code> does not subscribe to the Uni. It specifies the executor to use when a subscription happens.</p> <p>While the snippet above uses <code>Uni</code>, you can also use <code>runSubscriptionOn</code> on a <code>Multi</code>.</p>","tags":["guide","advanced"]},{"location":"guides/imperative-to-reactive/#executing-blocking-calls-on-event","title":"Executing blocking calls on event","text":"<p>Using <code>runSubscriptionOn</code> works when the blocking operation happens at subscription time. But, when dealing with <code>Multi</code> and need to execute blocking operations for each item, you need to use <code>emitOn</code>.</p> <p>While <code>runSubscriptionOn</code> runs the subscription on the given executor, <code>emitOn</code> configures the executor used to propagate downstream the items, failure and completion events:</p> <pre><code>Multi&lt;String&gt; multi = Multi.createFrom().items(\"john\", \"jack\", \"sue\")\n        .emitOn(Infrastructure.getDefaultWorkerPool())\n        .onItem().transform(this::invokeRemoteServiceUsingBlockingIO);\n</code></pre> <p><code>emitOn</code> is also available on <code>Uni</code>.</p> <p>Warning</p> <p>Be careful as this operator can lead to concurrency problems with non thread-safe objects such as CDI request-scoped beans. It might also break reactive-streams semantics with items being emitted concurrently.</p>","tags":["guide","advanced"]},{"location":"guides/integrate-a-non-reactive-source/","title":"How can I create a Multi from a non-reactive source?","text":"<p>The <code>UnicastProcessor</code> is an implementation of <code>Multi</code> that lets you enqueue items in a queue.</p> <p>The items are then dispatched to the subscriber using the request protocol. While this pattern is against the idea of back-pressure, it lets you connect sources of data that do not support back-pressure with your subscriber.</p> <p>In the following example, the <code>UnicastProcessor</code> is used by a thread emitting items. These items are enqueued in the processor and replayed when the subscriber is connected, following the request protocol.</p> <pre><code>UnicastProcessor&lt;String&gt; processor = UnicastProcessor.create();\nMulti&lt;String&gt; multi = processor\n        .onItem().transform(String::toUpperCase)\n        .onFailure().recoverWithItem(\"d'oh\");\n\n// Create a source of items that does not follow the request protocol\nnew Thread(() -&gt; {\n    for (int i = 0; i &lt; 1000; i++) {\n        processor.onNext(Integer.toString(i));\n    }\n    processor.onComplete();\n}).start();\n</code></pre> <p>By default, the <code>UnicastProcessor</code> uses an unbounded queue. You can also pass a fixed size queue that would reject the items once full.</p>","tags":["guide","advanced"]},{"location":"guides/joining-unis/","title":"Joining several unis","text":"<p>A <code>Uni</code> represents an operation that either emits a value or a failure. Examples of operations that fit into a <code>Uni</code> include: HTTP client requests, database <code>insert</code> queries, sending messages to a broker, etc.</p> <p>It is common to trigger several concurrent operations, then join on the results. For instance you can make HTTP requests to 3 different HTTP APIs, then collect all HTTP responses. Or you can just take the response from the one who was the fastest.</p> <p><code>Uni</code> offers the <code>join</code> group to assemble all results from a list of <code>Uni</code>, pick the first one that terminates, or pick the first one that terminates with a value.</p>","tags":["guide","intermediate"]},{"location":"guides/joining-unis/#joining-multiple-unis","title":"Joining multiple unis","text":"<p>Given multiple <code>Uni</code>, you can join them all and obtain a <code>Uni</code> that emits a list of values:</p> <pre><code>Uni&lt;Integer&gt; a = Uni.createFrom().item(1);\nUni&lt;Integer&gt; b = Uni.createFrom().item(2);\nUni&lt;Integer&gt; c = Uni.createFrom().item(3);\n\nUni&lt;List&lt;Integer&gt;&gt; res = Uni.join().all(a, b, c).andCollectFailures();\n</code></pre> <p>The assembled values are in the same order as the list of unis. The last call to <code>.andCollectFailures()</code> specifies that if one or several <code>Uni</code> fail, then the failures are assembled in a <code>CompositeException</code>.</p> <p>Sometimes you just want to fail fast if any of the <code>Uni</code> fails, and not wait for all unis to terminate:</p> <pre><code>res = Uni.join().all(a, b, c).andFailFast();\n</code></pre> <p>When any <code>Uni</code> fails, then the failure is directly forwarded as a failure of <code>res</code>.</p>","tags":["guide","intermediate"]},{"location":"guides/joining-unis/#joining-on-the-first-uni","title":"Joining on the first Uni","text":"<p>In some cases you do not want to have all the results but just that of the first <code>Uni</code> to respond. There are actually 2 different cases, depending on whether you want the result of the first <code>Uni</code> that emits a value, or just the result of the first <code>Uni</code> to terminate.</p> <p>If you want to get the first <code>Uni</code> that terminates:</p> <pre><code>Uni&lt;Integer&gt; res = Uni.join().first(a, b, c).toTerminate();\n</code></pre> <p>If you want to have the first <code>Uni</code> that emits a value (and forget the first failures), then:</p> <pre><code>res = Uni.join().first(a, b, c).withItem();\n</code></pre> <p>When all unis fail then <code>res</code> fails with a <code>CompositeException</code> that reports all failures.</p>","tags":["guide","intermediate"]},{"location":"guides/joining-unis/#using-a-builder-object","title":"Using a builder object","text":"<p>There are situations where it can be more convenient to gather the unis to join in an iterative fashion. For this purpose you can use a builder object, as in:</p> <pre><code>UniJoin.Builder&lt;Integer&gt; builder = Uni.join().builder();\n\nwhile (someCondition) {\n    Uni&lt;Integer&gt; uni = supplier.get();\n    builder.add(uni);\n}\n\nUni&lt;List&lt;Integer&gt;&gt; all = builder.joinAll().andFailFast();\n\nUni&lt;Integer&gt; first = builder.joinFirst().withItem();\n</code></pre> <p>The builder offers <code>joinAll()</code> and <code>joinFirst()</code> methods.</p>","tags":["guide","intermediate"]},{"location":"guides/kotlin/","title":"Kotlin integration","text":"<p>The module <code>mutiny-kotlin</code> provides an integration with Kotlin for use with coroutines and convenient language features.</p> <p>There are extension methods available for converting between Mutiny and Kotlin (coroutine) types. For implementation details please have also a look to these methods\u2019 documentation.</p>","tags":["guide","intermediate"]},{"location":"guides/kotlin/#dependency-coordinates","title":"Dependency coordinates","text":"<p>The coroutine extension functions are shipped in the package <code>io.smallrye.mutiny.coroutines</code>.</p> <pre><code>import io.smallrye.mutiny.coroutines.asFlow\nimport io.smallrye.mutiny.coroutines.asMulti\nimport io.smallrye.mutiny.coroutines.asUni\nimport io.smallrye.mutiny.coroutines.awaitSuspending\n</code></pre> <p>You need to add the following dependency to your project:</p> MavenGradle (Kotlin)Gradle (Groovy) <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;\n    &lt;artifactId&gt;mutiny-kotlin&lt;/artifactId&gt;\n    &lt;version&gt;2.8.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation(\"io.smallrye.reactive:mutiny-kotlin:2.8.0\")\n</code></pre> <pre><code>implementation \"io.smallrye.reactive:mutiny-kotlin:2.8.0\"\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/kotlin/#awaiting-a-uni-in-coroutines","title":"Awaiting a Uni in coroutines","text":"<p>Within a coroutine or suspend function you can easily await Uni events in a suspended way:</p> <pre><code>val uni: Uni&lt;String&gt; = Uni.createFrom().item(\"Mutiny \u2764 Kotlin\")\ntry {\n    // Available within suspend function and CoroutineScope\n    val item: String = uni.awaitSuspending()\n} catch (failure: Throwable) {\n    // onFailure event happened\n}\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/kotlin/#processing-a-multi-as-flow","title":"Processing a Multi as Flow","text":"<p>The coroutine <code>Flow</code> type matches <code>Multi</code> semantically, even though it isn\u2019t a feature complete reactive streams implementation. You can process a <code>Multi</code> as <code>Flow</code> as follows:</p> <pre><code>val multi: Multi&lt;String&gt; = Multi.createFrom().items(\"Mutiny\", \"\u2764\", \"Kotlin\")\nval flow: Flow&lt;String&gt; = multi.asFlow()\n</code></pre> <p>Note</p> <p>There\u2019s no flow control availabe for Kotlin\u2019s <code>Flow</code>. Published items are buffered for consumption using a coroutine <code>Channel</code>. The buffer size and overflow strategy of that <code>Channel</code> can be configured using optional arguments: <code>Multi.asFlow(bufferCapacity = Channel.UNLIMITED, bufferOverflowStrategy = BufferOverflow.SUSPEND)</code>, for more details please consult the method documentation.</p>","tags":["guide","intermediate"]},{"location":"guides/kotlin/#providing-a-deferred-value-as-uni","title":"Providing a Deferred value as Uni","text":"<p>The other way around is also possible, let a Deferred become a Uni:</p> <pre><code>val deferred: Deferred&lt;String&gt; = GlobalScope.async { \"Kotlin \u2764 Mutiny\" }\nval uni: Uni&lt;String&gt; = deferred.asUni()\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/kotlin/#creating-a-multi-from-a-flow","title":"Creating a Multi from a Flow","text":"<p>Finally, creating a Multi from a Flow is also possible:</p> <pre><code>val flow: Flow&lt;String&gt; = flowOf(\"Kotlin\", \"\u2764\", \"Mutiny\")\nval multi: Multi&lt;String&gt; = flow.asMulti()\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/kotlin/#language-convenience","title":"Language convenience","text":"","tags":["guide","intermediate"]},{"location":"guides/kotlin/#unit-instead-of-void-null-value","title":"Unit instead of Void (null) value","text":"<p>Kotlin has a special value type <code>Unit</code> similar to Java\u2019s <code>Void</code>. While regular <code>Uni&lt;Void&gt;</code> holds a <code>null</code> item, you can get a <code>Unit</code> by using the extension function <code>replaceWithUnit()</code>:</p> <pre><code>// import io.smallrye.mutiny.replaceWithUnit\nval unitUni : Uni&lt;Unit&gt; = uni.replaceWithUnit()\nassert(unitUni.await().indefinitely() === Unit)\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/kotlin/#uni-builder","title":"Uni builder","text":"<p>Building a <code>Uni</code> from Kotlin code can easily be achieved using the following builders available as regular or coroutine variant:</p> <pre><code>// import io.smallrye.mutiny.uni\nval uni: Uni&lt;String&gt; = uni { \"\u03bb \ud83d\udea7\" }\n</code></pre> <pre><code>// import io.smallrye.mutiny.coroutines.uni\ncoroutineScope {\n    val uni: Uni&lt;String&gt; = uni { \"\u03bb \ud83d\udea7\" }\n}\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/logging/","title":"Logging events","text":"<p>Both <code>Uni</code> and <code>Multi</code> offer a <code>log</code> operator that can be used to trace events as they flow through operators.</p> <p>Mutiny does not make any assumption on how logging is defined, and does not rely on any specific logging API.</p>","tags":["guide","beginner"]},{"location":"guides/logging/#using-a-logging-operator","title":"Using a logging operator","text":"<p>The <code>log</code> method comes in 2 forms: one that takes an identifier and one that derives the identifier from the upstream class:</p> <pre><code>Multi.createFrom().items(1, 2, 3)\n        .onItem().transform(n -&gt; n * 10)\n        .log()\n        .subscribe().with(item -&gt; System.out.println(\"&gt;&gt;&gt; \" + item));\n</code></pre> <p>Here the <code>log</code> operator traces all events between the <code>onItem().transform(...)</code> operator and the subscriber, as in the following output:</p> <pre><code>11:01:48.709 [main] INFO Multi.MultiMapOp.0 - onSubscription()\n11:01:48.711 [main] INFO Multi.MultiMapOp.0 - request(9223372036854775807)\n11:01:48.711 [main] INFO Multi.MultiMapOp.0 - onItem(10)\n&gt;&gt;&gt; 10\n11:01:48.711 [main] INFO Multi.MultiMapOp.0 - onItem(20)\n&gt;&gt;&gt; 20\n11:01:48.711 [main] INFO Multi.MultiMapOp.0 - onItem(30)\n&gt;&gt;&gt; 30\n11:01:48.711 [main] INFO Multi.MultiMapOp.0 - onCompletion()\n</code></pre> <p>There are a few things to note here:</p> <ol> <li>we are logging on a <code>Multi</code>, so the logging event is prefixed with <code>Multi</code> (and <code>Uni</code> in the case of a\u2026 <code>Uni</code>), and</li> <li>since we did not specify any identifier in the <code>log</code> method call, <code>MultiMapOp</code> has been derived from the preceding operator (non-qualified) class name, and</li> <li>since there can be multiple subscriptions an integer is appended to the identifier (<code>0</code>, <code>1</code>, <code>2</code>, \u2026).</li> </ol>","tags":["guide","beginner"]},{"location":"guides/logging/#defining-logging","title":"Defining logging","text":"<p>What happens when events are being logged is defined with the <code>Infrastructure</code> class. Events are written by default to the standard console output in a format similar to:</p> <pre><code>[--&gt; Multi.MultiMapOp.0 | onSubscription()\n[--&gt; Multi.MultiMapOp.0 | request(9223372036854775807)\n[--&gt; Multi.MultiMapOp.0 | onItem(10)\n[--&gt; Multi.MultiMapOp.0 | onItem(20)\n[--&gt; Multi.MultiMapOp.0 | onItem(30)\n[--&gt; Multi.MultiMapOp.0 | onCompletion()\n</code></pre> <p>The following is an example of configuring logging with http://www.slf4j.org[SLF4J]:</p> <pre><code>Infrastructure.setOperatorLogger((id, event, value, err) -&gt; {\n    Logger logger = LoggerFactory.getLogger(id);\n    if (err != null) {\n        logger.info(event + \"(\" + err.getClass() + \"(\" + err.getMessage() + \"))\");\n    } else {\n        if (value != null) {\n            logger.info(event + \"(\" + value + \")\");\n        } else {\n            logger.info(event + \"()\");\n        }\n    }\n});\n</code></pre> <p>Tip</p> <p>Note that this is only useful to do when embedding Mutiny in your own stack, some frameworks like Quarkus will already have defined the correct logging strategy.</p>","tags":["guide","beginner"]},{"location":"guides/merging-and-concatenating-streams/","title":"Merging and Concatenating Streams","text":"<p>Merging or concatenating streams is a frequent operation which consists in taking multiple streams and creating a new <code>Multi</code> out of them. Such an operation observes the items emitted by the different streams and produces a new <code>Multi</code> emitting the events.</p> <p>All the streams merged or concatenated this way should emit the same type of items.</p>","tags":["guide","intermediate"]},{"location":"guides/merging-and-concatenating-streams/#the-difference-between-merge-and-concatenate","title":"The difference between merge and concatenate","text":"<p>Understanding the difference between merge and concatenate is essential.</p> <p>When merging streams, it observes the different upstreams and emits the items as they come. If the streams emit their items concurrently, the items from the different streams are interleaved.</p> <pre><code>sequenceDiagram\n    autonumber\n    participant A as Stream A\n    participant B as Stream B\n    participant M as Merged stream\n\n    M--&gt;&gt;A: subscribe\n    M--&gt;&gt;B: subscribe    \n    A--&gt;&gt;M: onSubscribe(s)\n\n    A-&gt;&gt;M: onItem(1)\n\n    B--&gt;&gt;M: onSubscribe(s)\n\n    A-&gt;&gt;M: onItem(2)\n    B-&gt;&gt;M: onItem(a)    \n    A-&gt;&gt;M: onItem(3)\n    B-&gt;&gt;M: onItem(b)\n    B-&gt;&gt;M: onItem(c)</code></pre> <p>When using merge, failures are also propagated to the merged stream, and no more items are emitted after that failure. The completion event is only emitted by the merged stream when all the observed streams are completed.</p> <p>But if we want to keep the order of the observed stream, we need to concatenate.</p> <p>When concatenating, it waits for the first stream to complete before subscribing to the second one. Thus, it ensures that all the items from the first stream have been emitted before emitting the second stream items. It preserves an order corresponding to the source:</p> <pre><code>sequenceDiagram\n    autonumber\n    participant A as Stream A\n    participant B as Stream B\n    participant C as Concatenated stream\n\n    C--&gt;&gt;A: subscribe\n    A--&gt;&gt;C: onSubscribe(s)\n\n    A-&gt;&gt;C: onItem(1)\n    A-&gt;&gt;C: onItem(2)\n    A-&gt;&gt;C: onItem(3)\n\n    A--&gt;&gt;C: onCompletion()\n\n    C--&gt;&gt;B: subscribe\n    B--&gt;&gt;C: onSubscribe(s)\n\n    B-&gt;&gt;C: onItem(a)    \n    B-&gt;&gt;C: onItem(b)\n    B-&gt;&gt;C: onItem(c)</code></pre> <p>When the first stream emits the completion event, it switches to the second stream, and so on. When the last stream completes, the concatenated stream sends the completion event. As for merge, if a stream fails then there won\u2019t be further events.</p>","tags":["guide","intermediate"]},{"location":"guides/merging-and-concatenating-streams/#merging-multis","title":"Merging Multis","text":"<p>To create a new <code>Multi</code> from the merge of multiple <code>Multi</code> streams use:</p> <pre><code>Multi&lt;T&gt; multi1 = getFirstMulti();\nMulti&lt;T&gt; multi2 = getSecondMulti();\n\nMulti&lt;T&gt; merged = Multi.createBy().merging().streams(multi1, multi2);\n</code></pre> <p>For example, we can merge multiple streams emitting periodical events:</p> <pre><code>Multi&lt;String&gt; first = Multi.createFrom().ticks().every(Duration.ofMillis(10))\n        .onItem().transform(l -&gt; \"Stream 1 - \" + l);\n\nMulti&lt;String&gt; second = Multi.createFrom().ticks().every(Duration.ofMillis(15))\n        .onItem().transform(l -&gt; \"Stream 2 - \" + l);\n\nMulti&lt;String&gt; third = Multi.createFrom().ticks().every(Duration.ofMillis(5))\n        .onItem().transform(l -&gt; \"Stream 3 - \" + l);\n\nCancellable cancellable = Multi.createBy().merging().streams(first, second, third)\n        .subscribe().with(s -&gt; System.out.println(\"Got item: \" + s));\n</code></pre> <p>and the output would be similar to:</p> <pre><code>Got item: Stream 1 - 0\nGot item: Stream 2 - 0\nGot item: Stream 3 - 0\nGot item: Stream 3 - 1\nGot item: Stream 1 - 1\nGot item: Stream 3 - 2\nGot item: Stream 2 - 1\nGot item: Stream 3 - 3\nGot item: Stream 1 - 2\nGot item: Stream 3 - 4\nGot item: Stream 3 - 5\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/merging-and-concatenating-streams/#concatenating-multis","title":"Concatenating Multis","text":"<p>To create a new <code>Multi</code> from the concatenation of multiple <code>Multi</code> streams use:</p> <pre><code>Multi&lt;T&gt; multi1 = getFirstMulti();\nMulti&lt;T&gt; multi2 = getSecondMulti();\n\nMulti&lt;T&gt; concatenated = Multi.createBy().concatenating().streams(multi1, multi2);\n</code></pre> <p>Don\u2019t forget that the streams order matters in this case, as <code>(streamA, streamB)</code> does not provide the same result as <code>(streamB, streamA)</code>:</p> <pre><code>Multi&lt;String&gt; first = Multi.createFrom().items(\"A1\", \"A2\", \"A3\");\nMulti&lt;String&gt; second = Multi.createFrom().items(\"B1\", \"B2\", \"B3\");\n\nMulti.createBy().concatenating().streams(first, second)\n        .subscribe().with(item -&gt; System.out.print(item)); // \"A1A2A3B1B2B3\"\n\nMulti.createBy().concatenating().streams(second, first)\n        .subscribe().with(item -&gt; System.out.print(item)); // \"B1B2B3A1A2A3\"\n</code></pre> <p>Important</p> <p>If one of the concatenated streams is unbounded (infinite), the next streams in the list won\u2019t be consumed!</p>","tags":["guide","intermediate"]},{"location":"guides/multi-split/","title":"Splitting a Multi into several Multi","text":"<p>It is possible to split a <code>Multi</code> into several <code>Multi</code> streams.</p>","tags":["guide","intermediate"]},{"location":"guides/multi-split/#using-the-split-operator","title":"Using the split operator","text":"<p>Suppose that we have a stream of strings that represent signals, and that we want a <code>Multi</code> for each kind of signal:</p> <ul> <li><code>?foo</code>, <code>?bar</code> are input signals,</li> <li><code>!foo</code>, <code>!bar</code> are output signals,</li> <li><code>foo</code>, <code>bar</code> are other signals.</li> </ul> <p>To do that, we need a function that maps each item of the stream to its target stream. The splitter API needs a Java enumeration to define keys, as in:</p> <pre><code>enum Signals {\n    INPUT,\n    OUTPUT,\n    OTHER\n}\n</code></pre> <p>Now we can use the <code>split</code> operator that provides a splitter object, and fetch individual <code>Multi</code> for each split stream using the <code>get</code> method:</p> <pre><code>Multi&lt;String&gt; multi = Multi.createFrom().items(\n        \"!a\", \"?b\", \"!c\", \"!d\", \"123\", \"?e\"\n);\n\nvar splitter = multi.split(Signals.class, s -&gt; {\n    if (s.startsWith(\"?\")) {\n        return Signals.INPUT;\n    } else if (s.startsWith(\"!\")) {\n        return Signals.OUTPUT;\n    } else {\n        return Signals.OTHER;\n    }\n});\n\nsplitter.get(Signals.INPUT)\n        .onItem().transform(s -&gt; s.substring(1))\n        .subscribe().with(signal -&gt; System.out.println(\"input - \" + signal));\n\nsplitter.get(Signals.OUTPUT)\n        .onItem().transform(s -&gt; s.substring(1))\n        .subscribe().with(signal -&gt; System.out.println(\"output - \" + signal));\n\nsplitter.get(Signals.OTHER)\n        .subscribe().with(signal -&gt; System.out.println(\"other - \" + signal));\n</code></pre> <p>This prints the following console output:</p> <pre><code>output - a\ninput - b\noutput - c\noutput - d\nother - 123\ninput - e\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/multi-split/#notes-on-using-splits","title":"Notes on using splits","text":"<ul> <li>Items flow when all splits have a subscriber.</li> <li>The flow stops when either of the subscribers cancels, or when any subscriber has a no outstanding demand.</li> <li>The flow resumes when all splits have a subscriber again, and when all subscribers have outstanding demand.</li> <li>Only one subscriber can be active for a given split. Other subscription attempts will receive an error.</li> <li>When a subscriber cancels, then a new subscription attempt on its corresponding split can succeed.</li> <li>Subscribing to an already completed or errored split results in receiving the terminal signal (<code>onComplete()</code> or <code>onFailure(err)</code>).</li> <li>The upstream <code>Multi</code> gets subscribed to when the first split subscription happens, no matter which split it is.</li> <li>The first split subscription passes its context, if any, to the upstream <code>Multi</code>. It is expected that all split subscribers share the same context object, or the behavior of your code will most likely be incorrect.</li> </ul>","tags":["guide","intermediate"]},{"location":"guides/pagination/","title":"How to use paginated APIs?","text":"<p>There are many REST / HTTP APIs using pagination, i.e. return only a subset of the results and you need to request the next page to get the next batch. Each batch contains a list of item(s).</p> <p>To use this kind of API and generate a continuous stream of items, you need to use the <code>Multi.createBy().repeating()</code> function. However, we need to pass a cursor / state to advance and avoid requesting again and again the same page. Fortunately, <code>repeating</code> provides methods to pass a shared state. So by combining these methods and <code>disjoint</code> you can generate streams from these pages:</p> <pre><code>PaginatedApi api = new PaginatedApi();\n\nMulti&lt;String&gt; stream = Multi.createBy().repeating()\n        .completionStage(\n                () -&gt; new AtomicInteger(),\n                state -&gt; api.getPage(state.getAndIncrement()))\n        .until(list -&gt; list.isEmpty())\n        .onItem().disjoint();\n</code></pre> <p>First, you create a <code>Multi</code> containing the items emitted by the <code>CompletionStage</code> supplier and pass a state supplier to progress among the pages.</p> <p>Then, use <code>until</code> to call the paginated API until we have all the items. At the point we have a stream of list of item such as <code>[\"a\", \"b\", \"c\"], [\"d\", \"e\"], []</code>. However, we want the following stream: <code>\"a\", \"b\", \"c\", \"d\", \"e\"</code>. The <code>disjoint</code> method does exactly this. It gets the items from the lists and passes them downstream:</p> <pre><code>sequenceDiagram\n    autonumber\n    participant M as Multi\n    participant O as Disjoint operator\n    participant D as Subscriber\n\n    M-&gt;&gt;O: onItem([a,b,c])\n    O-&gt;&gt;D: onItem(a)\n    O-&gt;&gt;D: onItem(b)\n    O-&gt;&gt;D: onItem(c)\n    M-&gt;&gt;O: onItem([d,e])\n    O-&gt;&gt;D: onItem(d)\n    O-&gt;&gt;D: onItem(e)</code></pre> <p><code>Multi.createBy().repeating()</code> lets you choose the number of iterations using:</p> <ul> <li><code>atMost</code> - exact number of repetitions (or failure happens before reaching that number)</li> <li><code>until</code> - the repetition is stopped if the item emitted by the <code>Uni</code> passes a test (predicate).   It does not propagate the item that did pass the check, and it stops the repetition.   The check verifies if the current item does not contain valid data.</li> <li><code>whilst</code> - the repetition is stopped if the item emitted by the <code>Uni</code> does not pass a test (predicate).   It does propagate the item downstream even if the check does not pass.   However, it stops the repetition.   The test verifies if there is a next batch to be retrieved.</li> </ul> <p>The following code illustrates the usage of <code>whilst</code>:</p> <pre><code>PaginatedApi api = new PaginatedApi();\n\nMulti&lt;Page&gt; stream = Multi.createBy().repeating()\n        .uni(\n                () -&gt; new AtomicInteger(),\n                state -&gt; api.retrieve(state.getAndIncrement()))\n        .whilst(page -&gt; page.hasNext());\n</code></pre>","tags":["guide","intermediate"]},{"location":"guides/polling/","title":"How to use polling?","text":"<p>There are many poll-based API around us. Sometimes you need to use these APIs to generate a stream from the polled values.</p> <p>To do this, use the <code>repeat()</code> feature:</p> <pre><code>PollableDataSource source = new PollableDataSource();\n// First creates a uni that emit the polled item.\n// Because `poll` blocks, let's use a specific executor\nUni&lt;String&gt; pollItemFromSource = Uni.createFrom().item(source::poll)\n        .runSubscriptionOn(executor);\n// To get the stream of items, just repeat the uni indefinitely\nMulti&lt;String&gt; stream = pollItemFromSource.repeat().indefinitely();\n\nCancellable cancellable = stream.subscribe().with(item -&gt; System.out.println(\"Polled item: \" + item));\n// ... later ..\n// when you don't want the items anymore, cancel the subscription and close the source if needed.\ncancellable.cancel();\nsource.close();\n</code></pre> <p>You can also stop the repetition using the <code>repeat().until()</code> method which will continue the repetition until the given predicate returns <code>true</code>, and/or directly create a <code>Multi</code> using <code>Multi.createBy().repeating()</code>:</p> <pre><code>PollableDataSource source = new PollableDataSource();\nMulti&lt;String&gt; stream = Multi.createBy().repeating()\n            .supplier(source::poll)\n            .until(s -&gt; s == null)\n        .runSubscriptionOn(executor);\n\nstream.subscribe().with(item -&gt; System.out.println(\"Polled item: \" + item));\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/reactive-to-imperative/","title":"From reactive to imperative","text":"<p>There are use cases where you need the items in an imperative manner instead of asynchronous. Typically, when you serve an HTTP request from a worker thread, you can block.</p> <p>Mutiny provides the ability to block until you get the items.</p>","tags":["guide","advanced"]},{"location":"guides/reactive-to-imperative/#awaiting-on-unis-item","title":"Awaiting on Uni\u2019s item","text":"<p>When dealing with a <code>Uni,</code> you can block and await the item using:</p> <pre><code>T t = uni.await().indefinitely();\n</code></pre> <p>This method blocks the caller thread until the observed <code>uni</code> emits the item. Note that the returned item can be <code>null</code> if the <code>uni</code> emits <code>null.</code> If the <code>uni</code> fails, it throws the exception, wrapped in the <code>CompletionException</code> for checked exception.</p> <p>Blocking forever may not be a great idea. You can use <code>uni.await().atMost(Duration)</code> to pass a deadline. When the deadline is reached, a <code>TimeoutException</code> is thrown:</p> <pre><code>T t = uni.await().atMost(Duration.ofSeconds(1));\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/reactive-to-imperative/#iterating-over-multis-items","title":"Iterating over Multi\u2019s items","text":"<p>When dealing with a <code>Multi,</code> you may want to iterate over the items using a simple \u201cforeach.\u201d You can achieve this using <code>multi.subscribe().asIterable()</code>:</p> <pre><code>Iterable&lt;T&gt; iterable = multi.subscribe().asIterable();\nfor (T item : iterable) {\n    doSomethingWithItem(item);\n}\n</code></pre> <p>The returned <code>iterable</code> is blocking. It waits for the next items, and during that time, blocks the caller thread.</p> <p>The iteration ends once the last item is consumed. If the <code>multi</code> emits a failure, an exception is thrown.</p> <p>Similar to <code>asIterable()</code>, the <code>asStream</code> method lets you retrieve a <code>java.util.stream.Stream</code>:</p> <pre><code>Stream&lt;T&gt; stream = multi.subscribe().asStream();\nstream.forEach(this::doSomethingWithItem);\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/replaying-multis/","title":"Replaying Multis","text":"<p>A <code>Multi</code> is a cold-source: no processing happens until you subscribe.</p> <p>While the <code>broadcast</code> operator can be used so that multiple subscribers consume a <code>Multi</code> events at the same time, it does not support replaying items for late subscribers: when a subscriber joins after the <code>Multi</code> has completed (or failed), then it won\u2019t receive any item.</p> <p>This is where replaying can be useful.</p>","tags":["guide","advanced"]},{"location":"guides/replaying-multis/#replaying-all-events","title":"Replaying all events","text":"<p>Replaying all events from an upstream <code>Multi</code> works as follows:</p> <pre><code>Multi&lt;Integer&gt; upstream = Multi.createFrom().range(0, 10);\n\nMulti&lt;Integer&gt; replay = Multi.createBy().replaying().ofMulti(upstream);\n\nList&lt;Integer&gt; items_1 = replay.collect().asList().await().indefinitely();\nList&lt;Integer&gt; items_2 = replay.collect().asList().await().indefinitely();\n</code></pre> <p>Both <code>item_1</code> and <code>item_2</code> trigger new subscriptions, and both lists contain the following elements:</p> <pre><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre> <p>Replaying works by turning <code>upstream</code> into a hot-stream, meaning that it gets requested <code>Long.MAX_VALUE</code> elements. This is done when the first subscription happens.</p> <p>The replay operator stores the items in an internal replay log, and then each subscriber gets to replay them.</p> <p>Important</p> <p>Subscribers demand and cancellation requests are honored while replaying, but <code>upstream</code> cannot be cancelled.</p> <p>Be careful with unbounded streams as you can exhaust memory!</p> <p>In such cases or when you need to replay large amounts of data, you might opt to use some eventing middleware rather than Mutiny replays.</p>","tags":["guide","advanced"]},{"location":"guides/replaying-multis/#replaying-the-last-n-events","title":"Replaying the last \u2018n\u2019 events","text":"<p>You can limit the number of elements to replay by using the <code>upTo</code> method:</p> <pre><code>Multi&lt;Integer&gt; upstream = Multi.createFrom().range(0, 10);\n\nMulti&lt;Integer&gt; replay = Multi.createBy().replaying().upTo(3).ofMulti(upstream);\n\nList&lt;Integer&gt; items_1 = replay.collect().asList().await().indefinitely();\nList&lt;Integer&gt; items_2 = replay.collect().asList().await().indefinitely();\n</code></pre> <p>Each new subscriber gets to replay the last <code>n</code> elements from where the replay log is at subscription time. For instance the first subscriber can observe all events, while a subscriber that joins 2 seconds later might not observe the earlier events.</p> <p>Since <code>Multi.createFrom().range(0, 10)</code> is an immediate stream, both <code>item_1</code> and <code>item_2</code> lists contain the last items:</p> <pre><code>[7, 8, 9]\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/replaying-multis/#prepending-with-seed-data","title":"Prepending with seed data","text":"<p>In some cases you might want to prepend some seed data that will be available for replay before the upstream starts emitting.</p> <p>You can do so using an <code>Iterable</code> to provide such seed data:</p> <pre><code>Multi&lt;Integer&gt; upstream = Multi.createFrom().range(0, 10);\nIterable&lt;Integer&gt; seed = Arrays.asList(-10, -5, -1);\n\nMulti&lt;Integer&gt; replay = Multi.createBy().replaying().ofSeedAndMulti(seed, upstream);\n\nList&lt;Integer&gt; items_1 = replay.collect().asList().await().indefinitely();\nList&lt;Integer&gt; items_2 = replay.collect().asList().await().indefinitely();\n</code></pre> <p>In which case subscribers can observe the following events:</p> <pre><code>[-10, -5, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/replaying-multis/#replay-of-failures-and-completions","title":"Replay of failures and completions","text":"<p>Subscribers get to observe not just items but also the failure and completion events:</p> <pre><code>Multi&lt;Integer&gt; upstream = Multi.createBy().concatenating().streams(\n        Multi.createFrom().range(0, 10),\n        Multi.createFrom().failure(() -&gt; new IOException(\"boom\"))\n);\n\nMulti&lt;Integer&gt; replay = Multi.createBy().replaying().upTo(3).ofMulti(upstream);\n\nreplay.subscribe().with(\n        n -&gt; System.out.println(\" -&gt; \" + n),\n        failure -&gt; System.out.println(\"Failed: \" + failure.getMessage()),\n        () -&gt; System.out.println(\"Completed\"));\n</code></pre> <p>Running this code yields the following output for any subscriber:</p> <pre><code>-&gt; 7\n-&gt; 8\n-&gt; 9\nFailed: boom\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/rx/","title":"Using map, flatMap and concatMap","text":"<p>If you are a seasoned reactive developer, you may miss the <code>map</code>, <code>flatMap</code>, <code>concatMap</code> methods.</p> <p>The Mutiny API is quite different from the standard reactive eXtensions API.</p> <p>There are multiple reasons for this choice. Typically, flatMap is not necessarily well understood by every developer, leading to potentially catastrophic consequences.</p> <p>That being said, Mutiny provides the map, flatMap and concatMap methods, implementing the most common variant for each:</p> <pre><code>int result = uni\n        .map(i -&gt; i + 1)\n        .await().indefinitely();\n\nint result2 = uni\n        .flatMap(i -&gt; Uni.createFrom().item(i + 1))\n        .await().indefinitely();\n\nList&lt;Integer&gt; list = multi\n        .map(i -&gt; i + 1)\n        .collect().asList()\n        .await().indefinitely();\n\nList&lt;Integer&gt; list2 = multi\n        .flatMap(i -&gt; Multi.createFrom().items(i, i))\n        .collect().asList()\n        .await().indefinitely();\n\nList&lt;Integer&gt; list3 = multi\n        .concatMap(i -&gt; Multi.createFrom().items(i, i))\n        .collect().asList()\n        .await().indefinitely();\n</code></pre> <p>The Mutiny equivalents are:</p> <ul> <li><code>map -&gt; onItem().transform()</code></li> <li><code>flatMap -&gt; onItem().transformToUniAndMerge</code> and <code>onItem().transformToMultiAndMerge</code></li> <li><code>concatMap -&gt; onItem().transformToUniAndConcatenate</code> and <code>onItem().transformToMultiAndConcatenate</code></li> </ul> <p>The following snippet demonstrates how to uses these methods:</p> <pre><code>int result = uni\n        .onItem().transform(i -&gt; i + 1)\n        .await().indefinitely();\n\nint result2 = uni\n        .onItem().transformToUni(i -&gt; Uni.createFrom().item(i + 1))\n        .await().indefinitely();\n\n// Shortcut for .onItem().transformToUni\nint result3 = uni\n        .chain(i -&gt; Uni.createFrom().item(i + 1))\n        .await().indefinitely();\n\nList&lt;Integer&gt; list = multi\n        .onItem().transform(i -&gt; i + 1)\n        .collect().asList()\n        .await().indefinitely();\n\nList&lt;Integer&gt; list2 = multi\n        .onItem().transformToMultiAndMerge(i -&gt; Multi.createFrom().items(i, i))\n        .collect().asList()\n        .await().indefinitely();\n\n// Equivalent to transformToMultiAndMerge but let you configure the flattening process,\n// failure management, concurrency...\nList&lt;Integer&gt; list3 = multi\n        .onItem().transformToMulti(i -&gt; Multi.createFrom().items(i, i)).merge()\n        .collect().asList()\n        .await().indefinitely();\n\nList&lt;Integer&gt; list4 = multi\n        .onItem().transformToMultiAndConcatenate(i -&gt; Multi.createFrom().items(i, i))\n        .collect().asList()\n        .await().indefinitely();\n\n// Equivalent to transformToMultiAndConcatenate but let you configure the flattening process,\n// failure management...\nList&lt;Integer&gt; list5 = multi\n        .onItem().transformToMulti(i -&gt; Multi.createFrom().items(i, i)).concatenate()\n        .collect().asList()\n        .await().indefinitely();\n</code></pre>","tags":["guide","advanced"]},{"location":"guides/shortcut-methods/","title":"Shortcut methods","text":"<p>The Mutiny API is decomposed around the idea of groups, each group handling a specific event. However, to avoid verbosity, Mutiny also exposes shortcuts for the most used methods. Be aware that these shorts, while making the code shorter, may harm the readability and understandability.</p> <p>To peek at items, you can use the <code>invoke</code> method:</p> <pre><code>Multi&lt;String&gt; multi = Multi.createFrom().items(\"a\", \"b\", \"c\");\nmulti.invoke(item -&gt; System.out.println(\"Received item \" + item));\n</code></pre> <p><code>invoke</code> is a shortcut for <code>onItem().invoke(...)</code>.</p> <p>Mutiny also provides the <code>call</code> method for executing an action returning a <code>Uni</code>. This is useful to execute an asynchronous action without modifying incoming item:</p> <p><pre><code>multi.call(item -&gt; executeAnAsyncAction(item));\n</code></pre> <code>call</code> is a shortcut for <code>onItem().call(...)</code>.</p> <p>The following table lists the available shortcuts available by the <code>Uni</code> class:</p> Shortcut Equivalent <code>uni.map(x -&gt; y)</code> <code>uni.onItem().transform(x -&gt; y)</code> <code>uni.flatMap(x -&gt; uni2)</code> <code>uni.onItem().transformToUni(x -&gt; uni2)</code> <code>uni.chain(x -&gt; uni2)</code> <code>uni.onItem().transformToUni(x -&gt; uni2)</code> <code>uni.invoke(x -&gt; System.out.println(x))</code> <code>uni.onItem().invoke(x -&gt; System.out.println(x))</code> <code>uni.call(x -&gt; uni2)</code> <code>uni.onItem().call(x -&gt; uni2)</code> <code>uni.eventually(() -&gt; System.out.println(\"eventually\"))</code> <code>uni.onTermination().invoke(() -&gt; System.out.println(\"eventually\"))</code> <code>uni.eventually(() -&gt; uni2)</code> <code>uni.onTermination().call((ignoredItem, ignoredError, ignoredCancellation) -&gt; uni2)</code> <code>uni.replaceWith(x)</code> <code>uni.onItem().transform(ignored -&gt; x)</code> <code>uni.replaceWith(uni2)</code> <code>uni.onItem().transformToUni(ignored -&gt; uni2)</code> <code>uni.replaceIfNullWith(x)</code> <code>uni.onItem().ifNull().continueWith(x)</code>","tags":["guide","beginner"]},{"location":"guides/spies/","title":"Spying on events","text":"<p>Spies are useful when you need to track which events flow into a <code>Uni</code> or a <code>Multi</code>. Spies can track events from groups such as <code>onItem()</code>, <code>onFailure()</code>, <code>onSubscribe()</code>, etc.</p> <p>The <code>io.smallrye.mutiny.helpers.spies.Spy</code> interface offers factory methods to spy on selected groups, or even on all groups.</p>","tags":["guide","advanced"]},{"location":"guides/spies/#spying-selected-groups","title":"Spying selected groups","text":"<p>The following example spies on requests and completion group events:</p> <pre><code>Multi&lt;Integer&gt; multi = Multi.createFrom().items(1, 2, 3);\nMultiOnRequestSpy&lt;Integer&gt; requestSpy = Spy.onRequest(multi);\nMultiOnCompletionSpy&lt;Integer&gt; completionSpy = Spy.onCompletion(requestSpy);\n\ncompletionSpy.subscribe().with(System.out::println);\n\nSystem.out.println(\"Number of requests: \" + requestSpy.requestedCount());\nSystem.out.println(\"Completed? \" + completionSpy.invoked());\n</code></pre> <p>The standard output stream shall display the following text:</p> <pre><code>1\n2\n3\nNumber of requests: 9223372036854775807\nCompleted? true\n</code></pre> <p>The number of requests corresponds to <code>Long.MAX_VALUE</code>, and a completion event was sent.</p> <p>Important</p> <p>It is important to note that spies observe and report events for all subscribers, not just one in particular.</p> <p>You should call the <code>.reset()</code> method on a given spy to resets its statistics such as the invocation count.</p>","tags":["guide","advanced"]},{"location":"guides/spies/#spying-all-groups","title":"Spying all groups","text":"<p>You can take advantage of a global spy if you are interested in all event groups:</p> <pre><code>Multi&lt;Integer&gt; multi = Multi.createFrom().items(1, 2, 3);\nMultiGlobalSpy&lt;Integer&gt; spy = Spy.globally(multi);\n\nspy.subscribe().with(System.out::println);\n\nSystem.out.println(\"Number of requests: \" + spy.onRequestSpy().requestedCount());\nSystem.out.println(\"Cancelled? \" + spy.onCancellationSpy().isCancelled());\nSystem.out.println(\"Failure? \" + spy.onFailureSpy().lastFailure());\nSystem.out.println(\"Items: \" + spy.onItemSpy().items());\n</code></pre> <p>Running the snippet above gives the following output:</p> <pre><code>1\n2\n3\nNumber of requests: 9223372036854775807\nCancelled? false\nFailure? null\nItems: [1, 2, 3]\n</code></pre> <p>Warning</p> <p>Tracking <code>onItem()</code> events on a <code>Multi</code> requires storing all items into a list, which can yield an out-of-memory exception with large streams.</p> <p>In such cases consider using <code>Spy.onItem(multi, false)</code> to obtain a spy that does not store items, but that can still report data such as the number of received events (see <code>spy.invocationCount()</code>).</p>","tags":["guide","advanced"]},{"location":"guides/take-skip-items/","title":"Take/Skip the first or last items","text":"<p>Multi provides the ability to:</p> <ul> <li>only forward items from the beginning of the observed multi,</li> <li>only forward the last items (and discard all the other ones),</li> <li>skip items from the beginning of the multi,</li> <li>skip the last items.</li> </ul> <p>These actions are available from the <code>multi.select()</code> and <code>multi.skip()</code> groups, allowing to, respectively, select and skip items from upstream.</p>","tags":["guide","beginner"]},{"location":"guides/take-skip-items/#selecting-items","title":"Selecting items","text":"<p>The <code>multi.select().first</code> method forwards on the n first items from the multi. It forwards that amount of items and then sends the completion signal. It also cancels the upstream subscription.</p> <pre><code>Multi&lt;Integer&gt; firstThreeItems = multi.select().first(3);\n</code></pre> <p>Note</p> <p>The <code>select().first()</code> method selects only the first item.</p> <p>If the observed multi emits fewer items, it sends the completion event when the upstream completes.</p> <p>Similarly, The <code>multi.select().last</code> operator forwards on the n last items from the multi. It discards all the items emitted beforehand.</p> <pre><code>Multi&lt;Integer&gt; lastThreeItems = multi.select().last(3);\n</code></pre> <p>Note</p> <p>The <code>select().last()</code> method selects only the last item.</p> <p>The <code>multi.select().first(Predicate)</code> operator forwards the items while the passed predicate returns <code>true</code>:</p> <pre><code>Multi&lt;Integer&gt; takeWhile = multi.select().first(i -&gt; i &lt; 4);\n</code></pre> <p>It calls the predicate for each item. Once the predicate returns <code>false</code>, it stops forwarding the items downstream. It also sends the completion event and cancels the upstream subscription.</p> <p>Finally,  <code>multi.select().first(Duration)</code> operator picks the first items emitted during a given period. Once the passed duration expires, it sends the completion event and cancels the upstream subscription. If the observed multi completes before the passed duration, it sends the completion event.</p> <pre><code>Multi&lt;Integer&gt; takeForDuration = multi.select().first(Duration.ofSeconds(1));\n</code></pre>","tags":["guide","beginner"]},{"location":"guides/take-skip-items/#skipping-items","title":"Skipping items","text":"<p>You can also skip items using <code>multi.skip()</code>.</p> <p>The <code>multi.skip().first(n)</code> method skips the n first items from the multi. It forwards all the remaining items and sends the completion event when the upstream multi completes.</p> <pre><code>Multi&lt;Integer&gt; skipThreeItems = multi.skip().first(3);\n</code></pre> <p>If the observed multi emits fewer items, it sends the completion event without emitting any items.</p> <p>Note</p> <p><code>skip().last()</code> drops only the very last item.</p> <p>Similarly, The <code>multi.skip().last(n)</code> operator skips on the n last items from the multi:</p> <pre><code>Multi&lt;Integer&gt;  skipLastThreeItems = multi.skip().last(3);\n</code></pre> <p>The <code>multi.skip().first(Predicate)</code> operator skips the items while the passed predicate returns <code>true</code>:</p> <pre><code>Multi&lt;Integer&gt; skipWhile = multi.skip().first(i -&gt; i &lt; 4);\n</code></pre> <p>It calls the predicate for each item. Once the predicate returns <code>false</code>, it stops discarding the items and starts forwarding downstream.</p> <p>Finally,  <code>multi.skip().first(Duration)</code> operator skips the first items for a given period. Once the passed duration expires, it sends the items emitted after the deadline downstream. If the observed multi completes before the passed duration, it sends the completion event.</p> <pre><code>Multi&lt;Integer&gt; skipForDuration = multi.skip().first(Duration.ofSeconds(1));\n</code></pre>","tags":["guide","beginner"]},{"location":"guides/testing/","title":"How can I write unit / integration tests?","text":"<p>Mutiny provides subscribers for <code>Uni</code> and <code>Multi</code> offering helpful assertion methods. You can use them to test pipelines.</p> <p>Here is an example to test a <code>Uni</code>:</p> <pre><code>Uni&lt;Integer&gt; uni = Uni.createFrom().item(63);\n\nUniAssertSubscriber&lt;Integer&gt; subscriber = uni\n        .subscribe().withSubscriber(UniAssertSubscriber.create());\n\nsubscriber\n        .awaitItem()\n        .assertItem(63);\n</code></pre> <p>Testing a <code>Multi</code> pipeline is similar:</p> <pre><code>Multi&lt;Integer&gt; multi = Multi.createFrom().range(1, 5)\n        .onItem().transform(n -&gt; n * 10);\n\nAssertSubscriber&lt;Integer&gt; subscriber = multi.subscribe().withSubscriber(AssertSubscriber.create(10));\n\nsubscriber\n        .awaitCompletion()\n        .assertItems(10, 20, 30, 40);\n</code></pre> <p>The assertions do not just focus on good outcomes, you can also test failures as in:</p> <pre><code>Multi&lt;Object&gt; multi = Multi.createFrom().failure(() -&gt; new IOException(\"Boom\"));\n\nAssertSubscriber&lt;Object&gt; subscriber = multi\n        .subscribe().withSubscriber(AssertSubscriber.create(10));\n\nsubscriber\n        .awaitFailure()\n        .assertFailedWith(IOException.class, \"Boom\");\n</code></pre>","tags":["guide","beginner"]},{"location":"guides/unchecked-exceptions/","title":"Dealing with checked exceptions","text":"<p>When implementing your reactive pipeline, you write lots of functions (<code>java.util.function.Function</code>), consumers (<code>java.util.function.Consumer</code>), suppliers (<code>java.util.function.Supplier</code>) and so on.</p> <p>By default, you cannot throw checked exceptions.</p> <p>When integrating libraries throwing checked exceptions (like <code>IOException</code>) it\u2019s not very convenient to add a <code>try/catch</code> block and wrap the thrown exception into a runtime exception:</p> <pre><code>Uni&lt;Integer&gt; uni = item.onItem().transform(i -&gt; {\n    try {\n        return methodThrowingIoException(i);\n    } catch (IOException e) {\n        throw new UncheckedIOException(e);\n    }\n});\n</code></pre> <p>Mutiny provides utilities to avoid having to do this manually.</p> <p>If your operation throws a checked exception, you can use the <code>io.smallrye.mutiny.unchecked.Unchecked</code> wrappers.</p> <p>For example, if your synchronous transformation uses a method throwing a checked exception, wrap it using <code>Unchecked.function</code>:</p> <p><pre><code>Uni&lt;Integer&gt; uni = item.onItem().transform(Unchecked.function(i -&gt; {\n    // Can throw checked exception\n    return methodThrowingIoException(i);\n}));\n</code></pre> You can also wrap consumers such as in:</p> <pre><code>Uni&lt;Integer&gt; uni = item.onItem().invoke(Unchecked.consumer(i -&gt; {\n    // Can throw checked exception\n    throw new IOException(\"boom\");\n}));\n</code></pre> <p>Tip</p> <p>You can add the following import statement to simplify the usage of the provided methods:</p> <p><code>import static io.smallrye.mutiny.unchecked.Unchecked.*;</code></p>","tags":["guide","intermediate"]},{"location":"reference/going-reactive-a-few-pitfalls/","title":"Going reactive: a few pitfalls","text":"<p>Don\u2019t get us wrong, reactive programming is a fantastic way to write resource-efficient code!</p> <p>That being said, reactive programming has a learning curve that should not be taken lightly, and in some cases it is safer to write imperative code that you fully comprehend over reactive code that you don\u2019t fully grok.</p> <p>We have assembled a few considerations that we think new users should know before they embark into writing complex reactive business logic.</p>","tags":["reference","beginner"]},{"location":"reference/going-reactive-a-few-pitfalls/#mutiny-doesnt-auto-magically-make-your-code-asynchronous","title":"Mutiny doesn\u2019t auto-magically make your code asynchronous","text":"<p>This is a common source of confusion for new reactive programmers. Mutiny itself does not perform any scheduling work, except for the <code>emitOn</code> and <code>runSubscriptionOn</code> operators.</p> <p>Consider the following code where we join results from multiple asynchronous operations, materialised by the <code>Uni&lt;String&gt;</code>-returning <code>fetch</code> method: </p> <pre><code>Uni&lt;List&lt;String&gt;&gt; data = Uni.join().all(\n        fetch(\"abc\"),\n        fetch(\"def\"),\n        fetch(\"123\")).andFailFast();\n</code></pre> <p>You might think that the <code>join</code> operator schedules the calls to <code>fetch</code> to be run concurrently, and then collects the results into a list. This is not how it works!</p> <p>The <code>join</code> operator does subscribe to each <code>Uni&lt;String&gt;</code> returned by each call to <code>fetch</code>. When it receives a value, it puts it into a list, and when all values have been received, that list is emitted. The threads involved here are the ones that emit values in <code>fetch</code>. If <code>fetch</code> uses async I/O underneath then you should observe true concurrency, but if <code>fetch</code> just emits a value right when the subscription happens then you will merely observe a sequential execution of each call to <code>fetch</code>, in order.</p>","tags":["reference","beginner"]},{"location":"reference/going-reactive-a-few-pitfalls/#when-to-prefer-unilistt-over-multit","title":"When to prefer <code>Uni&lt;List&lt;T&gt;&gt;</code> over <code>Multi&lt;T&gt;</code>","text":"<p>The reason why <code>Multi</code> exists is to model streams over back-pressured sources. By conforming to the Reactive Streams protocol, a <code>Multi</code> respects the control flow requests from its subscribers, avoiding classic problems such as a fast producer and a slow consumer that can yield to memory exhaustion problems.</p> <p>That being said, not everything is a stream. Take the example of relational databases: databases don\u2019t stream! (for the most parts)</p> <p>When you do a query such as <code>SELECT * FROM ABC WHERE INDEX &lt; 123</code>, you get result rows. While you might wrap the results in a <code>Multi&lt;Row&gt;</code> as a convenience, the network protocol of the database still sends you all <code>Row</code> values and is very unlikely to support any notion of back-pressure on a SQL query result.</p> <p>This is why <code>Uni&lt;List&lt;Row&gt;&gt;</code> is in this case a better representation of an asynchronous operation than <code>Multi&lt;Row&gt;</code>, because the underlying networked service protocol does not provide you with any back-pressured stream.</p>","tags":["reference","beginner"]},{"location":"reference/going-reactive-a-few-pitfalls/#creating-uni-and-multi-from-in-memory-data-might-be-suspicious","title":"Creating <code>Uni</code> and <code>Multi</code> from in-memory data might be suspicious","text":"<p>You will find lots of occurrences of creating <code>Uni</code>  and <code>Multi</code> from in-memory data in this documentation, as in:</p> <pre><code>Uni&lt;Integer&gt; uni = Uni.createFrom().item(123);\nMulti&lt;Integer&gt; multi = Multi.createFrom().items(1, 2, 3, 4, 5);\n</code></pre> <p>This is convenient and expected when creating tests and examples, but this should be a strong warning in production. Indeed, if we have a method such as the following:</p> <pre><code>public Multi&lt;String&gt; fetchData(String key) {\n    List&lt;String&gt; strings = obtainValues(key);\n    return Multi.createFrom().iterable(strings);\n}\n</code></pre> <p>then it is clear that there is nothing \u201creactive\u201d in this code (sadly, you can find such idioms in some well-known \u201creactive\u201d client libraries, but we digress).</p> <p>As a rule of thumb, if your initial publisher does not make any I/O operation and it already has the data available in memory, then it is suspicious:</p> <ul> <li>if it is a <code>Uni</code>, then it does not really model an asynchronous I/O operation because the data is already here, and</li> <li>if it is a <code>Multi</code> then not only there is no asynchronous I/O operation involved, but there is no need for a back-pressure protocol either (see the previous section).</li> </ul> <p>What is not suspicious however is to create, say, a <code>Multi</code> to perform a transformation operation:</p> <pre><code>Multi&lt;String&gt; stream = streamData(\"abc\");\nreturn stream.onItem().transformToMultiAndMerge(line -&gt; {\n    if (line.trim().length() &gt; 10) {\n        return extractData(line);\n    } else {\n        return Multi.createFrom().item(\"[N/A]\");\n    }\n});\n</code></pre>","tags":["reference","beginner"]},{"location":"reference/migrating-to-mutiny-2/","title":"Migrating to Mutiny 2","text":"<p>The upgrade is transparent for most code bases that use Mutiny in applications (e.g., Quarkus applications).</p>","tags":["reference","beginner"]},{"location":"reference/migrating-to-mutiny-2/#highlights","title":"Highlights","text":"<ul> <li>Mutiny 2 is a major release with source and binary incompatible changes to the Mutiny <code>0.x</code> and <code>1.x</code> series.</li> <li>The main highlight of Mutiny 2 is that it is now based on top of the <code>java.util.concurrent.Flow</code> APIs instead of the legacy Reactive Streams APIs.</li> <li>The <code>Flow</code> APIs have been part of the JDK since Java 9, and they are the modern Reactive Streams APIs.</li> <li>Mutiny remains a faithful implementation of the Reactive Streams specification and passes the <code>Flow</code> variant of the Reactive Streams TCK.</li> <li>Deprecated APIs in Mutiny <code>1.x</code> have been removed, and experimental APIs have been promoted. </li> </ul>","tags":["reference","beginner"]},{"location":"reference/migrating-to-mutiny-2/#impact-of-the-switch-from-legacy-reactive-streams-apis-to-jdk-flow","title":"Impact of the switch from legacy Reactive Streams APIs to JDK Flow","text":"<ul> <li>The <code>Flow</code> types are isomorphic to the legacy Reactive Streams API types.</li> <li>We recommend that you migrate to <code>Flow</code> in your own code bases.</li> <li>You should encourage third-party libraries to migrate to <code>Flow</code>.</li> <li>You can always use adapters to go back and forth between <code>Flow</code> and legacy Reactive Streams types. </li> </ul>","tags":["reference","beginner"]},{"location":"reference/migrating-to-mutiny-2/#general-guidelines","title":"General guidelines","text":"<ul> <li>If your code only uses <code>Uni</code> and <code>Multi</code> (i.e., not <code>org.reactivestreams.Publisher</code>), then you will be source-compatible with Mutiny 2. You should still recompile and check that your test suites pass.</li> <li>If you expose <code>Multi</code> as a <code>org.reactivestreams.Publisher</code> then you will either need an adapter (see below) or migrate to <code>java.util.concurrent.Flow.Publisher</code>.</li> <li>If you interact with <code>org.reactivestreams.Publisher</code> publishers and you can\u2019t migrate them to <code>java.util.concurrent.Flow.Publisher</code> (e.g., because it is a third-party library), then you will need an adapter. Please encourage third-party libraries to migrate to <code>Flow</code>.</li> </ul>","tags":["reference","beginner"]},{"location":"reference/migrating-to-mutiny-2/#adapters-between-flow-and-legacy-reactive-streams-apis","title":"Adapters between Flow and legacy Reactive Streams APIs","text":"<ul> <li>We recommend using the adapters from the Mutiny Zero project.<ul> <li>The Maven coordinates are <code>groupId: io.smallrye.reactive</code>, <code>artifactId: mutiny-zero-flow-adapters</code></li> <li>Use <code>AdaptersToFlow</code> to convert from Reactive Streams types to <code>Flow</code> types, and</li> <li>Use <code>AdaptersToReactiveStreams</code> to convert <code>Flow</code> types to Reactive Streams types.</li> </ul> </li> <li>The Mutiny Zero adapters have virtually zero overhead.</li> </ul>","tags":["reference","beginner"]},{"location":"reference/migrating-to-mutiny-2/#other-api-changes","title":"Other API changes","text":"","tags":["reference","beginner"]},{"location":"reference/migrating-to-mutiny-2/#deprecated-api-removals","title":"Deprecated API removals","text":"<ul> <li><code>Uni</code> and <code>Multi</code> <code>onSubscribe()</code> group is now <code>onSubscription()</code>.</li> <li><code>AssertSubscriber.await()</code> has been replaced by event-specific methods (items, failure, completion, etc).</li> <li>The RxJava 2 integration module has been discarded (only RxJava 3 is now supported). </li> </ul>","tags":["reference","beginner"]},{"location":"reference/migrating-to-mutiny-2/#experimental-api-promotions","title":"Experimental API promotions","text":"<ul> <li><code>Uni</code> and <code>Multi</code> subscription-bound contexts.</li> <li><code>Uni.join()</code> publisher.</li> <li><code>.ifNoItem()</code> timeout operators.</li> <li><code>Uni</code> and <code>Multi</code> spies.</li> <li><code>capDemandsUsing()</code> and <code>paceDemand()</code> request management operators.</li> <li><code>Multi</code> <code>replay()</code> operator.</li> </ul>","tags":["reference","beginner"]},{"location":"reference/publications/","title":"Publications","text":"<p>Julien Ponge, Arthur Navarro, Cl\u00e9ment Escoffier, and Fr\u00e9d\u00e9ric Le Mou\u00ebl. 2021. Analysing the Performance and Costs of Reactive Programming Libraries in Java. In Proceedings of the 8<sup>th</sup> ACM SIGPLAN International Workshop on Reactive and Event-Based Languages and Systems (REBLS \u201921), October 18, 2021, Chicago, IL, USA. ACM, New York, NY, USA, 10 pages. (PDF)</p> <p>Modern services running in cloud and edge environments need to be resource-efficient to increase deployment density and reduce operating costs. Asynchronous I/O combined with asynchronous programming provides a solid technical foundation to reach these goals. Reactive programming and reactive streams are gaining traction in the Java ecosystem. However, reactive streams implementations tend to be complex to work with and maintain. This paper discusses the performance of the three major reactive streams compliant libraries used in Java applications: RxJava, Project Reactor, and SmallRye Mutiny. As we will show, advanced optimization techniques such as operator fusion do not yield better performance on realistic I/O-bound workloads, and they significantly increase development and maintenance costs.</p>","tags":["reference","advanced"]},{"location":"reference/uni-and-multi/","title":"Uni and Multi","text":"<p>Mutiny defines two reactive types:</p> <ul> <li><code>Multi</code> - represents streams of 0..* items (potentially unbounded)</li> <li><code>Uni</code> - represents streams receiving either an item or a failure</li> </ul> <p>Tip</p> <p>The Mutiny name comes from the contraction of <code>Multi</code> and <code>Uni</code> names</p> <p>Both <code>Uni</code> and <code>Multi</code> are asynchronous types. They receive and fire events at any time.</p> <p>You may wonder why we make the distinction between <code>Uni</code> and <code>Multi.</code> Conceptually, a <code>Uni</code> is a <code>Multi,</code> right?</p> <p>In practice, you don\u2019t use <code>Unis</code> and <code>Multis</code> the same way. The use cases and operations are different.</p> <ul> <li><code>Uni</code> does not need the complete ceremony presented above as the request does not make sense.</li> <li>The <code>subscribe</code> event expresses the interest and triggers the computation, no need for an additional request.</li> <li><code>Uni</code> can handle items having a <code>null</code> value (and has specific methods to handle this case).</li> <li><code>Multi</code> does not allow it (because the Reactive Streams specification forbids it).</li> <li>Having a <code>Uni</code> implementing <code>Publisher</code> would be a bit like having <code>Optional</code> implementing <code>Iterable</code>.</li> </ul> <p>In other words, <code>Uni</code>:</p> <ul> <li>can receive at most 1 <code>item</code> event, or a <code>failure</code> event</li> <li>cannot receive a <code>completion</code> event (<code>null</code> in the case of 0 items)</li> <li>cannot receive a <code>request</code> event</li> </ul> <p>The following snippet shows how you can use <code>Uni</code> and <code>Multi</code>:</p> <pre><code>Multi.createFrom().items(\"a\", \"b\", \"c\")\n  .onItem().transform(String::toUpperCase)\n  .subscribe().with(\n    item -&gt; System.out.println(\"Received: \" + item),\n    failure -&gt; System.out.println(\"Failed with \" + failure)\n);\n\nUni.createFrom().item(\"a\")\n  .onItem().transform(String::toUpperCase)\n  .subscribe().with(\n    item -&gt; System.out.println(\"Received: \" + item),\n    failure -&gt; System.out.println(\"Failed with \" + failure)\n);\n</code></pre>","tags":["reference","beginner"]},{"location":"reference/what-is-reactive-programming/","title":"What is Reactive Programming?","text":"<p>Mutiny is a reactive programming library. If you look on Wikipedia for reactive programming, you will find the following definition:</p> <p>Reactive Programming combines functional programming, the observer pattern, and the iterable pattern.</p> <p>While correct, we never found this definition very helpful. It does not convey clearly what\u2019s reactive programming is all about. So, let\u2019s make another definition, much more straightforward:</p> <p>Reactive programming is about programming with data streams.</p> <p>That\u2019s it. Reactive programming is about streams and especially, observing them. It pushes that idea to its limit: with reactive programming, everything is a data stream.</p> <p>With reactive programming, you observe streams and implement side effects when something flows in the stream:</p> <pre><code>sequenceDiagram\n    participant S1 as Stream\n    participant O1 as Observer\n\n    participant S2 as Stream\n    participant O2 as Observer\n\n    S1-&gt;&gt;O1: onItem(\"a\")\n    S2-&gt;&gt;O2: onItem(\"a\")\n\n    S1-&gt;&gt;O1: onItem(\"b\")\n    S2-&gt;&gt;O2: onItem(\"b\")\n\n    S2-&gt;&gt;O2: onItem(\"c\")\n\n    S1-XO1: onFailure(err)\n    S2-&gt;&gt;O2: onCompletion()</code></pre> <p>It\u2019s asynchronous by nature as you don\u2019t know when the data is going to be seen. Yet, reactive programming goes beyond this. It provides a toolbox to compose streams and process events.</p>","tags":["reference","beginner"]},{"location":"reference/what-makes-mutiny-different/","title":"What makes Mutiny different?","text":"<p>There are other reactive programming libraries out there. In the Java world,  we can mention Project Reactor and Rx Java.</p> <p>So, what makes Mutiny different from these two well-known libraries? The API!</p> <p>Asynchronous is hard to grasp for most developers, and for good reasons. Thus, the API must not require advanced knowledge or add cognitive overload. It should help you design your logic and still be intelligible when you return to the code 6 months later.</p> <p>To achieve this, Mutiny is built on three pillars:</p> <ul> <li>Event-Driven - with Mutiny, you listen for events and handle them,</li> <li>API Navigability - based on the event-driven nature, the API is built around the type of events and drive the navigation based on the kind of event you want to handle,</li> <li>Simplicity - Mutiny provides only two types (<code>Multi</code> and <code>Uni</code>), which can handle any kind of asynchronous interactions.</li> </ul>","tags":["reference","beginner"]},{"location":"reference/what-makes-mutiny-different/#events","title":"Events?","text":"<p>When you use Mutiny, you design a pipeline in which the events flow. Your code observes these events and react.</p> <p>Each processing stage is a new pipe you append to the pipeline. This pipe may change the events, create new ones, drops, buffers, whatever you need.</p> <p>In general, events flow from upstream to downstream, from source to sinks. Some events can swim upstream from the sinks to the source.</p> <p>Events going from upstream to downstream are published by <code>Publishers</code> and consumed by (downstream) <code>Subscribers,</code> which may also produce events for their own downstream, as illustrated by the following diagram:</p> <pre><code>sequenceDiagram\n   participant P as Publisher\n   participant O1 as Processor 1 \n   participant O2 as Processor 2 \n   participant S as Subscriber\n\n   P-&gt;&gt;O1: onItem\n   O1-&gt;&gt;O2: onItem\n   O2-&gt;&gt;S: onItem\n\n   P-&gt;&gt;O1: onItem\n   O1-&gt;&gt;O2: onItem\n   O2-&gt;&gt;S: onItem\n\n   P-&gt;&gt;O1: onCompletion\n   O1-&gt;&gt;O2: onCompletion\n   O2-&gt;&gt;S: onCompletion</code></pre> <p>Four types of events can flow in this direction:</p> <ul> <li>Subscribed - indicates that the upstream has taken into account the subscription - more on this later,</li> <li>Items - events containing some (business) value,</li> <li>Completion - event indicating that the source won\u2019t emit any more items,</li> <li>Failure - event telling that something terrible happened upstream and that the source cannot continue to emit items.</li> </ul> <p><code>Failure</code> and <code>Completion</code> are terminal events. Once they are sent, no more items will flow.</p> <p>Three types of events flow in the opposite direction, i.e. from downstream to upstream:</p> <ul> <li>Subscription - event sent by a subscriber to indicate its interest for the events (such as items) emitted by upstream</li> <li>Requests - event sent by a subscriber indicating how many items event it can handle - this is related to back-pressure</li> <li>Cancellation - event sent by a subscriber to stop the reception of events.</li> </ul> <p>In a typical scenario:</p> <ol> <li>A subscriber subscribes to the upstream - the upstream receive the <code>subscription request</code>, and when initialized sends the <code>subscribed</code> event to the subscriber</li> <li>The subscriber gets the <code>subscribed</code> event with a subscription used to emit the <code>requests</code> and <code>cancellation</code> events</li> <li>The subscriber sends a <code>request</code> event indicating how many items it can handle at this moment; it can request 1, n, or infinite.</li> <li>The publisher receiving the <code>request</code> event starts emitting at most n item events to the subscriber</li> <li>The subscriber can decide at any time to request more events or to cancel the subscription</li> </ol> <pre><code>sequenceDiagram\n   participant P as Publisher\n   participant O as Processor \n   participant S as Subscriber\n\n   S-&gt;&gt;O: subscribe\n   O-&gt;&gt;P: subscribe\n\n   P-&gt;&gt;O: subscription\n   O-&gt;&gt;S: subscription\n\n   S-&gt;&gt;O: request(5)\n   O-&gt;&gt;P: request(5)\n\n   P-&gt;&gt;O: onItem(\"a\")\n   O-&gt;&gt;S: onItem(\"A\")\n\n   P-&gt;&gt;O: onItem(\"b\")\n   O-&gt;&gt;S: onItem(\"B\")\n\n   S-&gt;&gt;O: cancel()\n   O-&gt;&gt;P: cancel()\n</code></pre> <p>The <code>request</code> event is the cornerstone of the back-pressure protocol. A subscriber should not request more than what it can handle, and a publisher should not emit more items than the amount of request received.</p> <p>Note</p> <p>Mutiny uses the Reactive Streams protocol for back-pressure management and the Java Flow APIs.</p> <p>Important</p> <p>Don\u2019t forget to subscribe!</p> <p>If no subscriber subscribes, no items will be emitted. More importantly, nothing will ever happen.</p> <p>If your program does not do anything, check that it subscribes, it\u2019s a very common error.</p>","tags":["reference","beginner"]},{"location":"reference/what-makes-mutiny-different/#an-event-driven-api","title":"An event-driven API?","text":"<p>Mutiny is an event-driven API.</p> <p>For each type of event, there is an <code>on</code> associated method that lets you handle this specific event. For example:</p> <pre><code>Multi&lt;String&gt; source = Multi.createFrom().items(\"a\", \"b\", \"c\");\nsource\n  .onItem() // Called for every item\n    .invoke(item -&gt; log(\"Received item \" + item))\n  .onFailure() // Called on failure\n    .invoke(failure -&gt; log(\"Failed with \" + failure))\n  .onCompletion() // Called when the stream completes\n    .invoke(() -&gt; log(\"Completed\"))\n  .onSubscription() // Called when the upstream is ready\n    .invoke(subscription -&gt; log(\"We are subscribed!\"))\n  .onCancellation() // Called when the downstream cancels\n    .invoke(() -&gt; log(\"Cancelled :-(\"))\n  .onRequest() // Called on downstream requests\n    .invoke(n -&gt; log(\"Downstream requested \" + n + \" items\"))\n  .subscribe()\n    .with(item -&gt; log(\"Subscriber received \" + item));\n</code></pre> <p>Of course, the methods presented in this snippet are not very interesting, although they are quite useful to trace what\u2019s going on.</p> <p>You can see a common pattern emerging:</p> <pre><code>.onEvent().invoke(event -&gt; ...);\n</code></pre> <p><code>invoke</code> is just one of the methods available. Each group proposes methods specific to the type of event. For example, <code>onFailure().recover</code>, <code>onCompletion().continueWith</code> and so on.</p>","tags":["reference","beginner"]},{"location":"reference/why-is-asynchronous-important/","title":"Why is asynchronous important?","text":"<p>We are living in a distributed world.</p> <p>Most of the applications built nowadays are distributed systems. The Cloud, IoT, microservices, mobile application, even simple CRUD applications are distributed applications.</p> <p>Still, developing distributed systems is hard!</p> <p></p> <p>Communications in distributed systems are inherently asynchronous and unreliable. Anything can go wrong, anytime, and often with no prior notice.</p> <p>Network disruptions, unavailable services, software, or hardware failures are just a tiny subset of the wide variety of failures that can happen in distributed systems.</p> <p>Correctly building distributed applications is a considerable challenge, as it requires re-assessing almost everything we know from traditional software development.</p> <p>Most classic applications use a synchronous development model. Synchronous code is easy to reason about, more comfortable to write and read than asynchronous code, but it has some hidden cost. This cost emerges when building I/O intensive applications, quite common in distributed applications.</p> <p>In general, these traditional applications assign one thread per request, and so they handle multiple concurrent requests with multiple threads. When the request processing needs to interact over the network, it uses that worker thread, which blocks the thread until the response has been received. This response may never come, so you need to add watchdogs handling timeouts and other resilience patterns. And, to handle more requests concurrently, you need to create more threads.</p> <p>Threads come at a cost. Each thread requires memory, and the more threads you have, the more CPU cycles are used to handle the context switches. Thus, this model ends up being costly, limits the deployment density, and on the Cloud means that you pay bigger bills.</p> <p>Fortunately, there is another way, and it relies on non-blocking I/O, an efficient way to handle I/O interactions that do not require additional threads. While applications using non-blocking I/O are more efficient and better suited for the Cloud\u2019s distributed nature, they come with a considerable constraint: you must never block the I/O thread.  Thus, you need to implement your business logic using an asynchronous development model.</p> <p>I/O is not the only reason why asynchronous is essential in Today\u2019s systems. Most of the interactions in the real world are asynchronous and event-driven. Representing these interactions using synchronous processes is not only wrong; it also introduces fragility in your application.</p> <p>Asynchronous is a significant shift. Mutiny helps you to take the plunge.</p>","tags":["reference","beginner"]},{"location":"tutorials/creating-multi-pipelines/","title":"Creating <code>Multi</code> pipelines","text":"<p>A <code>Multi</code> represents a stream of data. A stream can emit 0, 1, n, or an infinite number of items.</p> <p>You will rarely create instances of <code>Multi</code> yourself but instead use a reactive client that exposes a Mutiny API. Still, just like <code>Uni</code> there exists a rich API for creating <code>Multi</code> objects.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-multi-pipelines/#the-multi-type","title":"The Multi type","text":"<p>A <code>Multi&lt;T&gt;</code> is a data stream that:</p> <ul> <li>emits <code>0..n</code> item events</li> <li>emits a failure event</li> <li>emits a completion event for bounded streams</li> </ul> <p>Warning</p> <p>Failures are terminal events: after having received a failure no further item will be emitted.</p> <p><code>Multi&lt;T&gt;</code> provides many operators that create, transform, and orchestrate <code>Multi</code> sequences. The operators can be used to define a processing pipeline. The events flow in this pipeline, and each operator can process or transform the events.</p> <p><code>Multis</code> are lazy by nature. To trigger the computation, you must subscribe.</p> <p>The following snippet provides a simple example of pipeline using <code>Multi</code>:</p> <pre><code>Multi.createFrom().items(1, 2, 3, 4, 5)\n        .onItem().transform(i -&gt; i * 2)\n        .select().first(3)\n        .onFailure().recoverWithItem(0)\n        .subscribe().with(System.out::println);\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-multi-pipelines/#subscribing-to-a-multi","title":"Subscribing to a Multi","text":"<p>Remember, if you don\u2019t subscribe, nothing is going to happen. Also, the pipeline is materialized for each subscription.</p> <p>When subscribing to a <code>Multi,</code> you can pass an item callback (invoked when the item is emitted), or pass two callbacks, one receiving the item and one receiving the failure, or three callbacks to handle respectively the item, failure and completion events.</p> <pre><code>Cancellable cancellable = multi\n        .subscribe().with(\n                item -&gt; System.out.println(item),\n                failure -&gt; System.out.println(\"Failed with \" + failure),\n                () -&gt; System.out.println(\"Completed\"));\n</code></pre> <p>Note the returned <code>Cancellable</code>: this object allows canceling the stream if need be.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-multi-pipelines/#creating-multi-from-items","title":"Creating Multi from items","text":"<p>There are many ways to create <code>Multi</code> instances. See <code>Multi.createFrom()</code> to see all the possibilities.</p> <p>For instance, you can create a <code>Multi</code> from known items or from an <code>Iterable</code>:</p> <pre><code>Multi&lt;Integer&gt; multiFromItems = Multi.createFrom().items(1, 2, 3, 4);\nMulti&lt;Integer&gt; multiFromIterable = Multi.createFrom().iterable(Arrays.asList(1, 2, 3, 4, 5));\n</code></pre> <p>Every subscriber receives the same set of items (<code>1</code>, <code>2</code>\u2026 <code>5</code>) just after the subscription.</p> <p>You can also use <code>Suppliers</code>:</p> <pre><code>AtomicInteger counter = new AtomicInteger();\nMulti&lt;Integer&gt; multi = Multi.createFrom().items(() -&gt;\n        IntStream.range(counter.getAndIncrement(), counter.get() * 2).boxed());\n</code></pre> <p>The <code>Supplier</code> is called for every subscriber, so each of them will get different values.</p> <p>Tip</p> <p>You can create ranges using <code>Multi.createFrom().range(start, end)</code>.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-multi-pipelines/#creating-failing-multis","title":"Creating failing Multis","text":"<p>Streams can also fail.</p> <p>Failures are used to indicate to the downstream subscribers that the source encountered a terrible error and cannot continue emitting items. Create failed <code>Multi</code> instances with:</p> <pre><code>// Pass an exception directly:\nMulti&lt;Integer&gt; failed1 = Multi.createFrom().failure(new Exception(\"boom\"));\n\n// Pass a supplier called for every subscriber:\nMulti&lt;Integer&gt; failed2 = Multi.createFrom().failure(() -&gt; new Exception(\"boom\"));\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-multi-pipelines/#creating-empty-multis","title":"Creating empty Multis","text":"<p>Unlike <code>Uni,</code> <code>Multi</code> streams don\u2019t send <code>null</code> items (this is forbidden in reactive streams).</p> <p>Instead <code>Multi</code> streams send completion events indicating that there are no more items to consume. Of course, the completion event can happen even if there are no items, creating an empty stream.</p> <p>You can create such a stream using:</p> <pre><code>Multi&lt;String&gt; multi = Multi.createFrom().empty();\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-multi-pipelines/#creating-multis-using-an-emitter-advanced","title":"Creating Multis using an emitter (advanced)","text":"<p>You can create a <code>Multi</code> using an emitter. This approach is useful when integrating callback-based APIs:</p> <pre><code>Multi&lt;Integer&gt; multi = Multi.createFrom().emitter(em -&gt; {\n    em.emit(1);\n    em.emit(2);\n    em.emit(3);\n    em.complete();\n});\n</code></pre> <p>The emitter can also send a failure. It can also get notified of cancellation to, for example, stop the work in progress.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-multi-pipelines/#creating-multis-from-ticks-advanced","title":"Creating Multis from ticks (advanced)","text":"<p>You can create a stream that emit a ticks periodically:</p> <pre><code>Multi&lt;Long&gt; ticks = Multi.createFrom().ticks().every(Duration.ofMillis(100));\n</code></pre> <p>The downstream receives a <code>long,</code> which is a counter. For the first tick, it\u2019s 0, then 1, then 2, and so on.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-multi-pipelines/#creating-multis-from-a-generator-advanced","title":"Creating Multis from a generator (advanced)","text":"<p>You can create a stream from some initial state, and a generator function:</p> <pre><code>Multi&lt;Object&gt; sequence = Multi.createFrom().generator(() -&gt; 1, (n, emitter) -&gt; {\n    int next = n + (n / 2) + 1;\n    if (n &lt; 50) {\n        emitter.emit(next);\n\n    } else {\n        emitter.complete();\n    }\n    return next;\n});\n</code></pre> <p>The initial state is given through a supplier (here <code>() -&gt; 1</code>). The generator function accepts 2 arguments:</p> <ul> <li>the current state,</li> <li>an emitter that can emit a new item, emit a failure, or emit a completion.</li> </ul> <p>The generator function return value is the next current state. Running the previous example gives the following number suite: <code>{2, 4, 7, 11, 17, 26, 40, 61}</code>.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-uni-pipelines/","title":"Creating <code>Uni</code> pipelines","text":"<p>A <code>Uni</code> represents a stream that can only emit either an item or a failure event.</p> <p>You rarely create instances of <code>Uni</code> yourself, but, instead, use a reactive client exposing a Mutiny API that provides <code>Uni</code> objects.  That being said, it can be handy at times.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-uni-pipelines/#the-uni-type","title":"The Uni type","text":"<p>A <code>Uni&lt;T&gt;</code> is a specialized stream that emits only an item or a failure.  Typically, <code>Uni&lt;T&gt;</code> are great to represent asynchronous actions such as a remote procedure call, an HTTP request, or an operation producing a single result.</p> <p><code>Uni&lt;T&gt;</code> provides many operators that create, transform, and orchestrate <code>Uni</code> sequences.</p> <p>As said, <code>Uni&lt;T&gt;</code> emits either an item or a failure.  Note that the item can be <code>null,</code> and the <code>Uni</code> API has specific methods for this case. </p> <p>Typically, a <code>Uni&lt;Void&gt;</code> always emits <code>null</code> as item event or a failure if the represented operation fails.  You can consider the item event as a completion signal indicating the success of the operation.</p> <p>The offered operators can be used to define a processing pipeline. The event, either the item or failure, flows in this pipeline, and each operator can process or transform the event. <code>Unis</code> are lazy by nature. </p> <p>To trigger the computation, you must have a final subscriber indicating your interest. The following snippet provides a simple example of pipeline using <code>Uni</code>:</p> <pre><code>Uni.createFrom().item(1)\n        .onItem().transform(i -&gt; \"hello-\" + i)\n        .onItem().delayIt().by(Duration.ofMillis(100))\n        .subscribe().with(System.out::println);\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-uni-pipelines/#subscribing-to-a-uni","title":"Subscribing to a Uni","text":"<p>Important</p> <p>Remember: if you don\u2019t subscribe, nothing is going to happen. What\u2019s more, the pipeline is materialized for each subscription.</p> <p>When subscribing to a <code>Uni</code>, you can pass an item callback (invoked when the item is emitted), or two callbacks (one receiving the item and one receiving the failure):</p> <pre><code>Cancellable cancellable = uni\n        .subscribe().with(\n                item -&gt; System.out.println(item),\n                failure -&gt; System.out.println(\"Failed with \" + failure));\n</code></pre> <p>Note the returned <code>Cancellable</code>: this object allows canceling the operation if need be.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-uni-pipelines/#creating-unis-from-items","title":"Creating Unis from items","text":"<p>There are many ways to create <code>Uni</code> instances.  Use <code>Uni.createFrom()</code> to see all the possibilities.</p> <p>You can, for instance, create a <code>Uni</code> from a known value:</p> <pre><code>Uni&lt;Integer&gt; uni = Uni.createFrom().item(1);\n</code></pre> <p>Every subscriber receives the item <code>1</code> just after the subscription.</p> <p>You can also pass a <code>Supplier</code>:</p> <pre><code>AtomicInteger counter = new AtomicInteger();\nUni&lt;Integer&gt; uni = Uni.createFrom().item(() -&gt; counter.getAndIncrement());\n</code></pre> <p>The <code>Supplier</code> is called for every subscriber.  So, each of them will get a different value.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-uni-pipelines/#creating-failing-unis","title":"Creating failing Unis","text":"<p>Operations represented by <code>Unis</code> can also emit a failure event, indicating that the operation failed.</p> <p>You can create failed <code>Uni</code> instances with:</p> <pre><code>// Pass an exception directly:\nUni&lt;Integer&gt; failed1 = Uni.createFrom().failure(new Exception(\"boom\"));\n\n// Pass a supplier called for every subscriber:\nUni&lt;Integer&gt; failed2 = Uni.createFrom().failure(() -&gt; new Exception(\"boom\"));\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-uni-pipelines/#creating-univoid","title":"Creating <code>Uni&lt;Void&gt;</code>","text":"<p>When the represented operation to not produce a result, you still need a way to indicate the operation\u2019s completion. For this, you need to emit a <code>null</code> item:</p> <pre><code>Uni&lt;Void&gt; uni = Uni.createFrom().nullItem();\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-uni-pipelines/#creating-unis-using-an-emitter-advanced","title":"Creating Unis using an emitter (advanced)","text":"<p>You can create a <code>Uni</code> using an emitter. This approach is useful when integrating callback-based APIs:</p> <pre><code>Uni&lt;String&gt; uni = Uni.createFrom().emitter(em -&gt; {\n    // When the result is available, emit it\n    em.complete(result);\n});\n</code></pre> <p>The emitter can also send a failure. It can also get notified of cancellation to, for example, stop the work in progress.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/creating-uni-pipelines/#creating-unis-from-a-completionstage-advanced","title":"Creating Unis from a CompletionStage (advanced)","text":"<p>You can also <code>Uni</code> objects from <code>CompletionStage</code> / <code>CompletableFuture</code>.  This is useful when integrating with APIs that are based on these types:</p> <pre><code>Uni&lt;String&gt; uni = Uni.createFrom().completionStage(stage);\n</code></pre> <p>Tip</p> <p>You can also create a <code>CompletionStage</code> from a <code>Uni</code> using <code>uni.subscribe().asCompletionStage()</code></p>","tags":["tutorial","beginner"]},{"location":"tutorials/getting-mutiny/","title":"Getting started with Mutiny","text":"","tags":["tutorial","beginner"]},{"location":"tutorials/getting-mutiny/#using-mutiny-in-a-java-application","title":"Using Mutiny in a Java application","text":"<p>Add the dependency to your project using your preferred build tool:</p> Apache MavenGradle (Groovy)Gradle (Kotlin)JBang <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;\n    &lt;artifactId&gt;mutiny&lt;/artifactId&gt;\n    &lt;version&gt;2.8.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation 'io.smallrye.reactive:mutiny:2.8.0'\n</code></pre> <pre><code>implementation(\"io.smallrye.reactive:mutiny:2.8.0\")\n</code></pre> <pre><code>//DEPS io.smallrye.reactive:mutiny:2.8.0\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/getting-mutiny/#using-mutiny-with-quarkus","title":"Using Mutiny with Quarkus","text":"<p>Most of the Quarkus extensions with reactive capabilities already depend on Mutiny.</p> <p>You can also add the <code>quarkus-mutiny</code> dependency explicitly from the command-line:</p> <pre><code>mvn quarkus:add-extension -Dextensions=mutiny\n</code></pre> <p>or by editing the <code>pom.xml</code> file and adding:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n  &lt;artifactId&gt;quarkus-mutiny&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/getting-mutiny/#using-mutiny-with-vertx","title":"Using Mutiny with Vert.x","text":"<p>Most of the Eclipse Vert.x stack modules are available through the SmallRye Mutiny Vert.x Bindings project.</p> <p>Bindings for Vert.x modules are named by prepending <code>smallrye-mutiny-</code>. As an example here\u2019s how to add a dependency to the <code>vertx-core</code> Mutiny bindings:</p> Apache MavenGradle (Groovy)Gradle (Kotlin)JBang <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-mutiny-vertx-core&lt;/artifactId&gt;\n    &lt;version&gt;3.17.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation 'io.smallrye.reactive:smallrye-mutiny-vertx-core:3.17.1'\n</code></pre> <pre><code>implementation(\"io.smallrye.reactive:smallrye-mutiny-vertx-core:3.17.1\")\n</code></pre> <pre><code>//DEPS io.smallrye.reactive:smallrye-mutiny-vertx-core:3.17.1\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/handling-failures/","title":"Handling failures","text":"<p>Mutiny provides several operators to handle failures.</p> <p>Remember, failures are terminal events sent by the observed stream, indicating that something bad happened. After a failure, no more items are being received.</p> <p>When such an event is received, you can:</p> <ul> <li>propagate the failure downstream (default), or</li> <li>transform the failure into another failure, or</li> <li>recover from it by switching to another stream, passing a fallback item, or completing, or</li> <li>retrying (covered in the next guide)</li> </ul> <p>If you don\u2019t handle the failure event, it is propagated downstream until a stage handles the failure or reaches the final subscriber.</p> <p>Important</p> <p>on <code>Multi</code>, a failure cancels the subscription, meaning you will not receive any more items. The <code>retry</code> operator lets you re-subscribe and continue the reception.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/handling-failures/#observing-failures","title":"Observing failures","text":"<p>It can be useful to execute some custom action when a failure happens. For example, you can log the failure:</p> <pre><code>Uni&lt;String&gt; u = uni\n        .onFailure().invoke(failure -&gt; log(failure));\n\nMulti&lt;String&gt; m = multi\n        .onFailure().invoke(failure -&gt; log(failure));\n</code></pre> <p>Tip</p> <p>You can also execute an asynchronous action using <code>onFailure().call(Function&lt;Throwable, Uni&lt;?&gt;)</code>. The received failure will be propagated downstream when the <code>Uni</code> produced by the passed function emits its item.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/handling-failures/#transforming-failures","title":"Transforming failures","text":"<p>Another useful action on failure is to transform the failure into a more meaningful failure.</p> <p>Typically, you can wrap a low-level failure (like an <code>IOException</code>) into a business failure (<code>ServiceUnavailableException</code>):</p> <pre><code>Uni&lt;String&gt; u = uni\n        .onFailure().transform(failure -&gt;\n                new ServiceUnavailableException(failure));\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/handling-failures/#recovering-using-fallback-items","title":"Recovering using fallback item(s)","text":"<p>In general, upon failure, you want to recover. The first approach is to recover by replacing the failure with an item:</p> <pre><code>Uni&lt;String&gt; u1 = uni\n        .onFailure().recoverWithItem(\"hello\");\n\nUni&lt;String&gt; u2 = uni\n        .onFailure().recoverWithItem(f -&gt; getFallback(f));\n</code></pre> <p>The second approach receives a <code>Supplier</code> to compute the fallback item. For the downstream, it didn\u2019t fail; it gets the fallback item instead.</p> <p>However, don\u2019t forget that failures are terminal! So for <code>Multi</code>, the downstream receives the fallback item followed by the completion signal, as no more items can be produced.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/handling-failures/#completing-on-failure","title":"Completing on failure","text":"<p>When observing a <code>Multi</code> you can replace the failure with the completion signal:</p> <pre><code>Multi&lt;String&gt; m = multi\n        .onFailure().recoverWithCompletion();\n</code></pre> <p>The downstream won\u2019t see the failure, just the completion event.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/handling-failures/#switching-to-another-stream","title":"Switching to another stream","text":"<p>On failure, you may want to switch to an alternate stream. When the failure is received, it subscribes to this other stream and propagates the items from this stream instead:</p> <pre><code>Uni&lt;String&gt; u = uni\n        .onFailure().recoverWithUni(f -&gt; getFallbackUni(f));\n\nMulti&lt;String&gt; m = multi\n        .onFailure().recoverWithMulti(f -&gt; getFallbackMulti(f));\n</code></pre> <p>The <code>recoverWithUni</code> and <code>recoverWithMulti</code> methods replace the failed upstream with the returned stream.</p> <p>The fallback streams must produce the same type of event as the original upstream.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/hello-mutiny/","title":"Hello Mutiny!","text":"<p>Once you made Mutiny available to your classpath, you can start writing code. Let\u2019s start with this simple program:</p> <pre><code>import io.smallrye.mutiny.Uni;\n\npublic class FirstProgram {\n\n    public static void main(String[] args) {\n        Uni.createFrom().item(\"hello\")\n           .onItem().transform(item -&gt; item + \" mutiny\")\n           .onItem().transform(String::toUpperCase)\n           .subscribe().with(item -&gt; System.out.println(\"&gt;&gt; \" + item));\n    }\n}\n</code></pre> <p>This program prints:</p> <pre><code>&gt;&gt; HELLO MUTINY\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/hello-mutiny/#dissecting-the-pipeline","title":"Dissecting the pipeline","text":"<p>What\u2019s interesting is how this message is built. We described a processing pipeline taking an item, processing it and finally consuming it.</p> <p>First, we create a <code>Uni</code>, one of the two types with <code>Multi</code> that Mutiny provides. A <code>Uni</code> is a stream emitting either a single item or a failure.</p> <p>Here, we create a <code>Uni</code> emitting the <code>\"hello\"</code> item. This is the input of our pipeline. Then we process this item:</p> <ul> <li>we append <code>\" mutiny\"</code>, then</li> <li>we make it an uppercase string.</li> </ul> <p>This forms the processing part of our pipeline, and then we finally subscribe to the pipeline.</p> <p>This last part is essential. If you don\u2019t have a final subscriber, nothing is going to happen. Mutiny types are lazy, meaning that you need to express your interest. If you don\u2019t, the computation won\u2019t even start.</p> <p>Important</p> <p>If your program doesn\u2019t do anything, verify that you didn\u2019t forget to subscribe!</p>","tags":["tutorial","beginner"]},{"location":"tutorials/hello-mutiny/#mutiny-uses-a-builder-api","title":"Mutiny uses a builder API!","text":"<p>Another important aspect is the pipeline construction. Appending a new stage to a pipeline returns a new <code>Uni.</code></p> <p>The previous program is equivalent to:</p> <pre><code>Uni&lt;String&gt; uni1 = Uni.createFrom().item(\"hello\");\nUni&lt;String&gt; uni2 = uni1.onItem().transform(item -&gt; item + \" mutiny\");\nUni&lt;String&gt; uni3 = uni2.onItem().transform(String::toUpperCase);\n\nuni3.subscribe().with(item -&gt; System.out.println(\"&gt;&gt; \" + item));\n</code></pre> <p>It is fundamental to understand that this program is not equivalent to:</p> <pre><code>Uni&lt;String&gt; uni = Uni.createFrom().item(\"hello\");\n\nuni.onItem().transform(item -&gt; item + \" mutiny\");\nuni.onItem().transform(String::toUpperCase);\n\nuni.subscribe().with(item -&gt; System.out.println(\"&gt;&gt; \" + item));\n</code></pre> <p>This program just prints <code>\"&gt;&gt; hello\"</code>, as it does not use the appended stages and the final subscriber consumes the first <code>Uni.</code></p> <p>Warning</p> <p>Mutiny APIs are not fluent and each computation stage returns a new object.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/mutiny-workshop/","title":"Go further with the Mutiny workshop!","text":"<p>One great option to teach yourself Mutiny is to go through the Mutiny workshop examples.</p> <p>These self-contained JBang scripts cover the main parts of the Mutiny APIs.</p> <p>It\u2019s a fun and easy way to discover Mutiny!</p> <p>Check out https://github.com/smallrye/smallrye-mutiny/tree/main/workshop-examples to learn more.</p> <p></p>","tags":["tutorial","beginner"]},{"location":"tutorials/observing-events/","title":"Observing events","text":"<p>Learn how to observe the events emitted by <code>Uni</code> and <code>Multi</code> instances.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/observing-events/#events","title":"Events","text":"<p><code>Uni</code> and <code>Multi</code> emit events. Your code is going to observe and process these events.</p> <p>Most of the time, your code is only interested in item and failure events. But there are other kinds of events such as cancellation, request, completion, and so on:</p> Event Uni / Multi Direction Note item Uni + Multi upstream -&gt; downstream The upstream sent an item. failure Uni + Multi upstream -&gt; downstream The upstream failed. completion Multi upstream -&gt; downstream The upstream completed. subscribe Uni and Multi downstream -&gt; upstream A downstream subscriber is interested in the data. subscription Uni and Multi upstream -&gt; downstream Event happening after a <code>subscribe</code> event to indicate that the upstream acknowledged the subscription. cancellation Uni and Multi downstream -&gt; upstream A downstream subscriber does not want any more events. overflow Multi upstream -&gt; downstream The upstream has emitted more than the downstream can handle. request Multi downstream -&gt; upstream The downstream indicates its capacity to handle <code>n</code> items. <p>It\u2019s not rare that you need to look at these various events to understand better what\u2019s going on or implement specific side effects. For example, you may need to close a resource after a completion event or log a message on failure or cancellation.</p> <p>For each kind of event, there is an associated group providing the methods to handle that specific event: <code>onItem()</code>, <code>onFailure()</code>, <code>onCompletion()</code> and so on. These groups provide two methods to peek at the various events without impacting its distribution: <code>invoke(...)</code> and <code>call(...)</code>. It does not transform the received event; it notifies you that something happened and let you react. Once this reaction completes, the event is propagated downstream or upstream depending on the direction of the event.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/observing-events/#the-invoke-method","title":"The <code>invoke</code> method","text":"<p>The invoke method is synchronous and the passed callback does not return anything. Mutiny invokes the configured callback when the observed stream dispatches the event:</p> <pre><code>Uni&lt;String&gt; u = uni.onItem()\n    .invoke(i -&gt; System.out.println(\"Received item: \" + i));\n\nMulti&lt;String&gt; m = multi.onItem()\n    .invoke(i -&gt; System.out.println(\"Received item: \" + i));\n</code></pre> <p>As said above, <code>invoke</code> is synchronous. Mutiny invokes the callback and propagates the event downstream when the callback returns. It blocks the dispatching.</p> <pre><code>sequenceDiagram\n    autonumber\n    participant M as Multi\n    participant O as onItem().invoke(...)\n    participant D as Downstream\n\n    M-&gt;&gt;O: item1\n    O-&gt;&gt;D: item1\n\n    M-&gt;&gt;O: item2\n    O-&gt;&gt;D: item2\n\n    M-&gt;&gt;O: item3\n    Note over O: callback execution\n    O-&gt;&gt;D: item3</code></pre> <p>Of course, we highly recommend you not to block.</p> <p>The following snippets show how you can log the different types of events.</p> <pre><code>multi\n    .onSubscription()\n        .invoke(() -&gt; System.out.println(\"\u2b07\ufe0f Subscribed\"))\n    .onItem()\n        .invoke(i -&gt; System.out.println(\"\u2b07\ufe0f Received item: \" + i))\n    .onFailure()\n        .invoke(f -&gt; System.out.println(\"\u2b07\ufe0f Failed with \" + f))\n    .onCompletion()\n        .invoke(() -&gt; System.out.println(\"\u2b07\ufe0f Completed\"))\n    .onCancellation()\n        .invoke(() -&gt; System.out.println(\"\u2b06\ufe0f Cancelled\"))\n    .onRequest()\n        .invoke(l -&gt; System.out.println(\"\u2b06\ufe0f Requested: \" + l));\n</code></pre> <p>The arrows from the previous code snippet indicate if the event comes from the upstream (source) or downstream (consumer) (see the table above for more details). The <code>invoke</code> method does not change the event, except in one case. If the callback throws an exception, the downstream does not get the actual event but get a failure event instead.</p> <p>When observing the failure event, if the callback throws an exception, Mutiny propagates a <code>CompositeException</code> aggregating the original failure and the callback failure.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/observing-events/#the-call-method","title":"The <code>call</code> method","text":"<p>Unlike <code>invoke</code>, <code>call</code> is asynchronous, and the callback returns a <code>Uni&lt;?&gt;</code> object.</p> <p><code>call</code> is often used when you need to implement asynchronous side-effects, such as closing resources.</p> <pre><code>sequenceDiagram\n    autonumber\n    participant M as Multi\n    participant O as onItem().call(...)\n    participant U as Returned Unis\n    participant D as Downstream\n\n    M-&gt;&gt;O: item1\n    O--)U: item1\n    U--)O: result1\n    O-&gt;&gt;D: result1\n\n    M-&gt;&gt;O: item2\n    O--)U: item2\n    U--)O: result2\n    O-&gt;&gt;D: result2\n\n    M-&gt;&gt;O: item3\n    O--)U: item3\n    U--)O: result3\n    O-&gt;&gt;D: result3</code></pre> <p>Mutiny does not dispatch the original event downstream until the Uni returned by the callback emits an item:</p> <pre><code>multi\n    .onItem().call(i -&gt;\n        Uni.createFrom().voidItem()\n            .onItem().delayIt().by(Duration.ofSeconds(1)\n    )\n);\n</code></pre> <p>As shown in the previous snippet, you can use this approach to delay items. But, the primary use case is about completing asynchronous actions such as calling an asynchronous <code>close</code> method on a resource:</p> <pre><code>multi\n    .onCompletion().call(() -&gt; resource.close());\n</code></pre> <p>Under the hood, Mutiny gets the <code>Uni</code> (by invoking the callback) and subscribes to it. It observes the item or failure event from that Uni. It discards the item value as only the emission matters in this case.</p> <p>If the callback throws an exception or the produced <code>Uni</code> produces a failure, Mutiny propagates that failure (or a <code>CompositeException</code>) downstream, replacing the original event.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/observing-events/#summary","title":"Summary","text":"<ul> <li>The <code>invoke</code> and <code>call</code> methods are handy when you need to observe a <code>Uni</code> or a <code>Multi</code> without changing the transiting events.</li> <li>Use <code>invoke</code> for implementing synchronous side-effects or logging events.</li> <li>The asynchronous nature of <code>call</code> makes it perfect for implementing asynchronous side-effects, such as closing resources, flushing data, delay items, and so on.</li> </ul> <p>The following table highlights the key differences:</p> <code>invoke</code> <code>call</code> Nature synchronous asynchronous Return type <code>void</code> <code>Uni&lt;T&gt;</code> Main use cases logging, synchronous side-effects I/O operations, closing resources, flushing data","tags":["tutorial","beginner"]},{"location":"tutorials/retrying/","title":"Retrying on failures","text":"<p>It is common to want to retry if something terrible happened.</p> <p>You can retry upon failure. The How does retry\u2026 retries blog post provides a more detailed overview of the retry mechanism.</p> <p>Note</p> <p>If despite multiple attempts, it still fails, the failure is propagated downstream.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/retrying/#retry-multiple-times","title":"Retry multiple times","text":"<p>To retry on failure, use <code>onFailure().retry()</code>:</p> <pre><code>Uni&lt;String&gt; u = uni\n        .onFailure().retry().atMost(3);\nMulti&lt;String&gt; m = multi\n        .onFailure().retry().atMost(3);\n</code></pre> <p>You pass the number of retries as a parameter.</p> <p>Important</p> <p>While <code>.onFailure().retry().indefinitely()</code> is available, it may never terminate, so use it with caution.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/retrying/#introducing-delays","title":"Introducing delays","text":"<p>By default, <code>retry</code> retries immediately. When using remote services, it is often better to delay a bit the attempts.</p> <p>Mutiny provides a method to configure an exponential backoff: a growing delay between retries. Configure the exponential backoff as follows:</p> <pre><code>Uni&lt;String&gt; u = uni\n        .onFailure().retry()\n        .withBackOff(Duration.ofMillis(100), Duration.ofSeconds(1))\n        .atMost(3);\n</code></pre> <p>The backoff is configured with the initial and max delay. Optionally, you can also configure a jitter to add a pinch of randomness to the delay.</p> <p>When using exponential backoff, you may not want to configure the max number of attempts (<code>atMost</code>), but a deadline. To do so, use either <code>expireIn</code> or <code>expireAt</code>.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/retrying/#deciding-to-retry","title":"Deciding to retry","text":"<p>As an alternative to <code>atMost</code>, you can also use <code>until</code>. This method accepts a predicate called after every failure. When used, a backoff should not be used.</p> <p>If the predicate returned <code>true,</code> it retries. Otherwise, it stops retrying and propagates the last failure downstream:</p> <pre><code>Uni&lt;String&gt; u = uni\n        .onFailure().retry()\n        .until(f -&gt; shouldWeRetry(f));\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/transforming-items-asynchronously/","title":"Transforming items asynchronously","text":"<p>The previous examples illustrated how to transform each item from a stream into another item. Yet, there are cases where we need to go beyond this, for example:</p> <ul> <li>Transforming an item into a <code>Uni</code> \u2013 any asynchronous processing such as calling a remote service, interacting with a database, etc</li> <li>Transforming an item into a <code>Multi</code> \u2013 producing a multi-items stream based on the incoming item, filtering out items, etc</li> </ul> <p>Having the possibility to transform an item into a stream gives us many opportunities. To implement such transformations, we use <code>onItem().transformToUni(Function&lt;T, Uni&lt;O&gt;&gt;)</code> and <code>onItem().transformToMulti(Function&lt;T, Multi&lt;O&gt;&gt;)</code></p>","tags":["tutorial","beginner"]},{"location":"tutorials/transforming-items-asynchronously/#uni-transforming-an-item-into-a-uni","title":"Uni - Transforming an item into a Uni","text":"<pre><code>sequenceDiagram\n    autonumber\n    participant M as Uni\n    participant O as Transformer\n    participant U as Uni(item)\n    participant D as Subscriber\n\n    M-&gt;&gt;O: onItem(item)\n    O--)U: subscribe(...) \n    U--)O: onSubscribe(sub)\n    U--)O: onItem(result) \n    O-&gt;&gt;D: onItem(result)</code></pre> <p>Imagine that you have a <code>Uni&lt;String&gt;</code>, and you want to call a remote service.</p> <p>Calling a remote service is an asynchronous action represented by a <code>Uni</code>, as in:</p> <pre><code>Uni&lt;String&gt; invokeRemoteGreetingService(String name);\n</code></pre> <p>To call this service, you need to transform the item received from the first <code>Uni</code> into the <code>Uni</code> returned by the service:</p> <pre><code>Uni&lt;String&gt; result = uni\n    .onItem().transformToUni(name -&gt; invokeRemoteGreetingService(name));\n</code></pre> <p>This snippet chains the first <code>Uni</code> with another one. The returned <code>Uni</code> (<code>result</code>) emits the result from the remote service or a failure if anything wrong happened:</p> <pre><code>Uni&lt;String&gt; uni = Uni.createFrom().item(\"Cameron\");\nuni\n    .onItem().transformToUni(name -&gt; invokeRemoteGreetingService(name))\n    .subscribe().with(\n            item -&gt; System.out.println(item), // Print \"Hello Cameron\",\n            fail -&gt; fail.printStackTrace()); // Print the failure stack trace\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/transforming-items-asynchronously/#uni-transforming-an-item-into-a-multi","title":"Uni - Transforming an item into a Multi","text":"<p>The previous example produced a single item. You may want to transform the received item into a stream which is\u2026 a <code>Multi</code>!</p> <pre><code>Multi&lt;String&gt; result = uni\n    .onItem().transformToMulti(item -&gt; Multi.createFrom().items(item, item));\n</code></pre> <p>This code creates a stream of two elements, duplicating the received item.</p> <pre><code>uni\n    .onItem().transformToMulti(item -&gt; Multi.createFrom().items(item, item))\n    .subscribe().with(\n            item -&gt; System.out.println(item)); // Called twice\n</code></pre> <pre><code>sequenceDiagram\n    autonumber\n    participant M as Uni\n    participant O as Transformer\n    participant U as Multi(item)\n    participant D as Subscriber\n\n    M-&gt;&gt;O: onItem(item)\n    O--)U: subscribe(...) \n    U--)O: onSubscribe(sub)\n    U--)O: onItem(item)\n    O-&gt;&gt;D: onItem(item) \n    U--)O: onItem(item)\n    O-&gt;&gt;D: onItem(item)</code></pre> <p>The produced <code>Multi</code> objects can of course be more complicated than that and emit items in an asynchronous fashion.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/transforming-items-asynchronously/#transforming-items-from-multi-the-merge-vs-concatenate-dilemma","title":"Transforming items from Multi - the merge vs concatenate dilemma","text":"<p>When transforming items emitted by an upstream <code>Multi,</code> we need to answer the following question: how are we going to merge the produced items back?</p> <p>Let\u2019s take an example. Imagine a <code>Multi</code> emitting the <code>Cameron</code> and <code>Donna</code> items (in order), and you want to call the <code>invokeRemoteGreetingService</code> from above. It thus calls <code>invokeRemoteGreetingService(\"Cameron\")</code> then <code>invokeRemoteGreetingService(\"Donna\")</code>.</p> <p>The service does not have a constant response time (because of network latency or the load), which means that responses can be interleaved. Indeed, you may receive <code>\"Hello Donna\"</code> before <code>\"Hello Cameron\"</code>.</p> <p>Now, how do you want to handle this case? Do you need to preserve the order and ensure that the downstream subscriber will always get <code>\"Hello Cameron\"</code> first, or do you accept interleaved responses?</p> <p>When transforming items from <code>Multi</code> into streams, you need to decide in which order the items emitted by the produced stream are going to be received by the downstream subscriber. Mutiny offers two possibilities:</p> <ol> <li>Merging \u2013 it does not preserve the order and emits the items from the produced streams as they come, or</li> <li>Concatenating \u2013 it maintains and concatenates the streams produced for each item.</li> </ol>","tags":["tutorial","beginner"]},{"location":"tutorials/transforming-items-asynchronously/#multi-transforming-an-item-into-a-uni","title":"Multi - Transforming an item into a Uni","text":"<p>To implement the scenario from the last section, you will use <code>onItem().transformToUniAndMerge</code> or <code>onItem().transformToUniAndConcatenate()</code> depending on your ordering choice:</p> <pre><code>Multi&lt;String&gt; merged = multi\n    .onItem().transformToUniAndMerge(name -&gt; invokeRemoteGreetingService(name));\n\nMulti&lt;String&gt; concat = multi\n    .onItem().transformToUniAndConcatenate(name -&gt; invokeRemoteGreetingService(name));\n</code></pre> <p>Important</p> <ul> <li>When merging: items from the source <code>Multi</code> may be processed concurrently depending on the concurrency level that has been set, if any.</li> <li>When concatenating: items from the source <code>Multi</code> are processed in order, waiting for each <code>Uni</code> to complete before moving on to the next item. </li> </ul>","tags":["tutorial","beginner"]},{"location":"tutorials/transforming-items-asynchronously/#multi-transforming-an-item-into-a-multi","title":"Multi - Transforming an item into a Multi","text":"<p><code>onItem().transformToMultiAndMerge</code> and <code>onItem().transformToMultiAndConcatenate</code> transform incoming items into <code>Multi</code> streams. The produced <code>Multi</code> objects are either merged or concatenated:</p> <pre><code>Multi&lt;String&gt; merged = multi\n    .onItem().transformToMultiAndMerge(item -&gt; someMulti(item));\n\nMulti&lt;String&gt; concat = multi\n    .onItem().transformToMultiAndConcatenate(item -&gt; someMulti(item));\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/transforming-items/","title":"Transforming items","text":"<p>Both <code>Unis</code> and <code>Multis</code> emit items.</p> <p>One of the most common operations you will do is transforming these items using a synchronous 1-to-1 function.</p> <p>To achieve this, you use <code>onItem().transform(Function&lt;T, U&gt;)</code>. It calls the passed function for each item and produces the result as an item which is propagated downstream.</p> <pre><code>sequenceDiagram\n    autonumber\n    participant M as Multi\n    participant O as Transformer\n    participant D as Subscriber\n\n    M-&gt;&gt;O: onItem(a1)\n    O-&gt;&gt;D: onItem(a2)\n\n    M-&gt;&gt;O: onItem(b1)\n    O-&gt;&gt;D: onItem(b2)\n\n    M-&gt;&gt;O: onItem(c1)\n    O-&gt;&gt;D: onItem(c2)</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/transforming-items/#transforming-items-produced-by-a-uni","title":"Transforming items produced by a Uni","text":"<p>Let\u2019s imagine you have a <code>Uni&lt;String&gt;,</code> and you want to capitalize the received <code>String</code>. Implementing this transformation is done as follows:</p> <pre><code>Uni&lt;String&gt; someUni = Uni.createFrom().item(\"hello\");\nsomeUni\n        .onItem().transform(i -&gt; i.toUpperCase())\n        .subscribe().with(\n                item -&gt; System.out.println(item)); // Print HELLO\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/transforming-items/#transforming-items-produced-by-a-multi","title":"Transforming items produced by a Multi","text":"<p>The only difference for <code>Multi</code> is that the function is called for each item:</p> <pre><code>Multi&lt;String&gt; m = multi.onItem().transform(i -&gt; i.toUpperCase());\n</code></pre> <p>The produced items are passed to the downstream subscriber:</p> <pre><code>Multi&lt;String&gt; someMulti = Multi.createFrom().items(\"a\", \"b\", \"c\");\nsomeMulti\n        .onItem().transform(i -&gt; i.toUpperCase())\n        .subscribe().with(\n                item -&gt; System.out.println(item)); // Print A B C\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tutorials/transforming-items/#what-if-the-transformation-failed","title":"What if the transformation failed?","text":"<p>If the transformation throws an exception, that exception is caught and passed to the downstream subscriber as a failure event. It also means that the subscriber won\u2019t get further item after that failure.</p>","tags":["tutorial","beginner"]},{"location":"tutorials/transforming-items/#chaining-multiple-transformations","title":"Chaining multiple transformations","text":"<p>You can chain multiple transformations:</p> <pre><code>Uni&lt;String&gt; u = uni\n        .onItem().transform(i -&gt; i.toUpperCase())\n        .onItem().transform(i -&gt; i + \"!\");\n</code></pre>","tags":["tutorial","beginner"]},{"location":"tags-index/","title":"Index","text":""},{"location":"tags-index/#document-kinds","title":"Document kinds","text":"Tag Description <code>tutorial</code> Tutorials to get started with Mutiny. <code>guides</code> Topic-centric guides on how to use Mutiny. <code>reference</code> Reference documents to understand core concepts in Mutiny."},{"location":"tags-index/#audience-level","title":"Audience level","text":"Tag Description <code>beginner</code> Reading materials if you are new to Mutiny <code>intermediate</code> Intermediate operations beyond the basics <code>advanced</code> Advanced operations beyond classic usage of Mutiny"},{"location":"tags-index/#tags","title":"Tags","text":""},{"location":"tags-index/#advanced","title":"advanced","text":"<ul> <li>Context passing</li> <li>Controlling the demand</li> <li>Using other reactive programming libraries</li> <li>Can I have custom operators?</li> <li>How to deal with dropped exceptions?</li> <li>How can I integrate Mutiny with my framework?</li> <li>Hot streams</li> <li>From imperative to reactive</li> <li>How can I create a Multi from a non-reactive source?</li> <li>How to use polling?</li> <li>From reactive to imperative</li> <li>Replaying Multis</li> <li>Using map, flatMap and concatMap</li> <li>Spying on events</li> <li>Publications</li> </ul>"},{"location":"tags-index/#beginner","title":"beginner","text":"<ul> <li>Broadcasting to multiple subscribers (like server-sent events, websockets, etc)</li> <li>Collecting items from Multi</li> <li>Eliminate duplicates and repetitions</li> <li>Filtering items from Multi</li> <li>How to handle null?</li> <li>Logging events</li> <li>Shortcut methods</li> <li>Take/Skip the first or last items</li> <li>How can I write unit / integration tests?</li> <li>Going reactive: a few pitfalls</li> <li>Migrating to Mutiny 2</li> <li>Uni and Multi</li> <li>What is Reactive Programming?</li> <li>What makes Mutiny different?</li> <li>Why is asynchronous important?</li> <li>Creating Multi pipelines</li> <li>Creating Uni pipelines</li> <li>Getting started with Mutiny</li> <li>Handling failures</li> <li>Hello Mutiny!</li> <li>Go further with the Mutiny workshop!</li> <li>Observing events</li> <li>Retrying on failures</li> <li>Transforming items asynchronously</li> <li>Transforming items</li> </ul>"},{"location":"tags-index/#guide","title":"guide","text":"<ul> <li>How to do branching in a reactive pipeline?</li> <li>Broadcasting to multiple subscribers (like server-sent events, websockets, etc)</li> <li>Collecting items from Multi</li> <li>Combining items from streams</li> <li>How to deal with CompletionStage?</li> <li>Context passing</li> <li>Controlling the demand</li> <li>Using other reactive programming libraries</li> <li>Can I have custom operators?</li> <li>How to delay events?</li> <li>How to deal with dropped exceptions?</li> <li>Eliminate duplicates and repetitions</li> <li>How to change the emission thread?</li> <li>What is the difference between emitOn and runSubscriptionOn?</li> <li>Filtering items from Multi</li> <li>How can I integrate Mutiny with my framework?</li> <li>How to handle null?</li> <li>How to handle timeouts?</li> <li>Hot streams</li> <li>From imperative to reactive</li> <li>How can I create a Multi from a non-reactive source?</li> <li>Joining several unis</li> <li>Kotlin integration</li> <li>Logging events</li> <li>Merging and Concatenating Streams</li> <li>Splitting a Multi into several Multi</li> <li>How to use paginated APIs?</li> <li>How to use polling?</li> <li>From reactive to imperative</li> <li>Replaying Multis</li> <li>Using map, flatMap and concatMap</li> <li>Shortcut methods</li> <li>Spying on events</li> <li>Take/Skip the first or last items</li> <li>How can I write unit / integration tests?</li> <li>Dealing with checked exceptions</li> </ul>"},{"location":"tags-index/#intermediate","title":"intermediate","text":"<ul> <li>How to do branching in a reactive pipeline?</li> <li>Combining items from streams</li> <li>How to deal with CompletionStage?</li> <li>How to delay events?</li> <li>How to change the emission thread?</li> <li>What is the difference between emitOn and runSubscriptionOn?</li> <li>How to handle timeouts?</li> <li>Joining several unis</li> <li>Kotlin integration</li> <li>Merging and Concatenating Streams</li> <li>Splitting a Multi into several Multi</li> <li>How to use paginated APIs?</li> <li>Dealing with checked exceptions</li> </ul>"},{"location":"tags-index/#reference","title":"reference","text":"<ul> <li>Going reactive: a few pitfalls</li> <li>Migrating to Mutiny 2</li> <li>Publications</li> <li>Uni and Multi</li> <li>What is Reactive Programming?</li> <li>What makes Mutiny different?</li> <li>Why is asynchronous important?</li> </ul>"},{"location":"tags-index/#tutorial","title":"tutorial","text":"<ul> <li>Creating Multi pipelines</li> <li>Creating Uni pipelines</li> <li>Getting started with Mutiny</li> <li>Handling failures</li> <li>Hello Mutiny!</li> <li>Go further with the Mutiny workshop!</li> <li>Observing events</li> <li>Retrying on failures</li> <li>Transforming items asynchronously</li> <li>Transforming items</li> </ul>"}]}